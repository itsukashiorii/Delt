<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ultimate Image Editor</title>
  <link rel="icon" href="wuthering waves shoorekeeper.jpg" type="image/png"/>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
  --bg1: url('wuthering waves shoorekeeper1.jpg');
  --bg2: url('wuthering waves shoorekeeper2.jpg');
  --bg3: url('wuthering waves shoorekeeper3.jpg');
  --bg4: url('wuthering waves shoorekeeper4.jpg');
  --bg5: url('wuthering waves shoorekeeper5.jpg');
  --bg6: url('wuthering waves shoorekeeper6.jpg');
  --bg7: url('wuthering waves shoorekeeper7.jpg');
  --bg8: url('wuthering waves shoorekeeper8.jpg');
  --bg9: url('wuthering waves shoorekeeper9.jpg');
  --bg10: url('wuthering waves shoorekeeper10.jpg');
      --accent: #00bcd4;
      --accent-dark: #008ba3;
      --text: #eee;
      --text-light: #fff;
      --text-muted: #bbb;
      --bg-overlay: rgba(0, 0, 0, 0.65);
      --panel-bg: rgba(49,255,75,0);
      --panel-border: rgba(255, 255, 255, 0.2);
      --card-bg: rgba(87,255,108,0);
      --card-bg-hover: rgba(255, 255, 255, 0.15);
      --glow: 0 0 15px rgba(0, 188, 212, 0.4);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Poppins', sans-serif;
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: var(--bg1) center/cover fixed;
      transition: background-image 1.5s ease-in-out;
      position: relative;
    }
    body::before { 
      content: ""; 
      position: absolute; 
      inset: 0; 
      background: var(--bg-overlay); 
      z-index: -1; 
    }

    h1 {
      font-family: 'JetBrains Mono', monospace;
      font-size: 2.8em; 
      margin-bottom: 25px; 
      letter-spacing: 2px;
      color: var(--text-light);
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
      background: linear-gradient(90deg, #00bcd4, #00ffaa);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      padding: 0 15px;
    }

    #toast {
      position: fixed; 
      top: 25px; 
      right: 25px; 
      background: #4caf50; 
      color: #fff;
      padding: 15px 25px; 
      border-radius: 8px; 
      font-weight: 600;
      box-shadow: 0 0 15px rgba(0,0,0,0.3); 
      opacity: 0; 
      transform: translateY(-30px);
      transition: all 0.4s ease; 
      z-index: 9999; 
      display: flex; 
      align-items: center; 
      gap: 10px;
    }
    #toast.show { opacity: 1; transform: translateY(0); }
    #toast.error { background: #f44336; }

    .panel {
      background: var(--panel-bg); 
      border: 1px solid var(--panel-border); 
      border-radius: 16px;
      padding: 35px 40px; 
      width: 100%; 
      max-width: 1200px; 
      display: grid; 
      grid-template-columns: 1fr 2fr; 
      gap: 40px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
      transition: all 0.3s;
      backdrop-filter: blur(0px);
    }
    .panel:hover { 
      transform: translateY(-5px); 
      box-shadow: 0 15px 35px rgba(0,0,0,0.6);
    }

    .controls { 
      display: flex; 
      flex-direction: column; 
      gap: 25px; 
    }
    .control-group { 
      display: flex; 
      flex-direction: column; 
      gap: 15px; 
    }
    .control-group-title { 
      font-size: 1.1em; 
      font-weight: 600; 
      color: var(--text-light); 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .control-group-title i { 
      color: var(--accent); 
      font-size: 1.2em;
    }
    .controls label { 
      font-size: 0.95em; 
      color: var(--text); 
      font-weight: 600; 
      display: block;
      margin-bottom: 5px;
    }
    .controls input[type="file"] {
      color: var(--text); 
      font-size: 0.9em; 
      width: 100%; 
      padding: 10px;
      background: rgba(240,0,0,0); 
      border: 1px dashed rgba(255,255,255,0.3); 
      border-radius: 8px;
      transition: all 0.3s;
    }
    .controls input[type="file"]:hover {
      background: rgba(255,255,255,0.15);
      border-color: var(--accent);
    }
    .controls input[type="range"] { 
      width: 100%; 
      margin-top: 6px; 
      height: 6px;
      accent-color: var(--accent); 
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
    }
    select, button {
      padding: 12px 18px; 
      border: 1px solid rgba(255,255,255,0.2); 
      background: hsla(0,100%,51.2%,0);
      color: #fff; 
      border-radius: 8px; 
      font-size: 0.95em; 
      transition: all 0.3s; 
      width: 100%;
    }
    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 15px;
    }
    select:focus, button:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: var(--glow);
    }
    button {
      cursor: pointer; 
      font-weight: 600; 
      background: linear-gradient(135deg, rgba(0,188,212,0.3), rgba(0,150,200,0.4));
      border-color: var(--accent);
      display: flex; 
      align-items: center; 
      justify-content: center; 
      gap: 8px;
    }
    button:hover { 
      background: linear-gradient(135deg, rgba(0,188,212,0.5), rgba(0,150,200,0.6));
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(0);
    }
    button:disabled { 
      opacity: 0.5; 
      cursor: not-allowed; 
      transform: none !important;
    }

    .preview-wrapper {
      position: relative; 
      border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 12px; 
      overflow: hidden;
      background: rgba(0,0,0,0.1); 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center;
      min-height: 400px; 
      height: 100%;
      transition: all 0.3s;
    }
    .preview-wrapper:hover {
      border-color: var(--accent);
      box-shadow: var(--glow);
    }
    #preview { 
      width: 100%; 
      max-height: 500px; 
      object-fit: contain; 
      border-radius: 4px; 
      display: none; 
    }
    canvas { display: none; }
    .placeholder-text {
      color: var(--text-muted);
      font-size: 1.1em;
      text-align: center;
      padding: 0 20px;
    }
    .placeholder-text i {
      font-size: 2em;
      margin-bottom: 15px;
      color: var(--accent);
      opacity: 0.7;
    }

    .info-panel { 
      width: 100%; 
      margin-top: 15px; 
      font-family: 'JetBrains Mono', monospace; 
      border-radius: 12px; 
      overflow: hidden; 
      transition: all 0.3s ease; 
      max-height: 500px; 
    }
    .info-header {
      background: rgba(0,188,212,0.2); 
      padding: 12px 15px; 
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      cursor: pointer; 
      border: 1px solid var(--accent); 
      border-radius: 8px;
      transition: all 0.3s;
    }
    .info-header:hover { 
      background: rgba(0,188,212,0.3); 
      box-shadow: var(--glow);
    }
    .info-header span { 
      font-weight: 600; 
      display: flex; 
      align-items: center; 
      gap: 8px; 
    }
    .info-content {
      background: var(--panel-bg); 
      border: 1px solid var(--panel-border); 
      border-top: none; 
      border-radius: 0 0 8px 8px;
      padding: 15px; 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 15px;
    }
    .info-card { 
      background: var(--card-bg); 
      border-radius: 8px; 
      padding: 12px 15px; 
      border-left: 3px solid var(--accent); 
      transition: all 0.3s; 
    }
    .info-card:hover { 
      background: var(--card-bg-hover); 
      transform: translateY(-3px);
    }
    .info-card span { 
      display: block; 
      font-weight: 700; 
      font-size: 1.05em; 
      color: var(--text-light); 
    }
    .info-card small { 
      color: var(--text-muted); 
      font-size: 0.85em; 
    }

    /* Filter controls styling */
    .filter-controls {
      display: none;
      background: rgba(0,0,0,0.3);
      padding: 15px;
      border-radius: 8px;
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .filter-controls.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    .filter-control {
      margin-bottom: 15px;
    }
    .filter-control:last-child {
      margin-bottom: 0;
    }
    .filter-control label {
      display: block;
      margin-bottom: 8px;
      font-size: 0.9em;
    }
    .filter-control-value {
      float: right;
      font-weight: 700;
      color: var(--accent);
    }

    /* Tab Layout - Vertikal */
    .tab-layout {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .tab-container {
      display: flex;
      flex-direction: column;
      border-right: none;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-right: 0;
      margin-bottom: 15px;
      width: 100%;
      gap: 5px;
    }
    
    .tab {
      padding: 12px 15px;
      cursor: pointer;
      font-size: 0.9em;
      border-left: 3px solid transparent;
      border-radius: 0 8px 8px 0;
      transition: all 0.3s;
      text-align: left;
      background: rgba(255,255,255,0.05);
    }
    
    .tab.active {
      border-left-color: var(--accent);
      background: rgba(0,188,212,0.15);
      color: var(--text-light);
    }
    
    .tab:hover:not(.active) {
      background: rgba(255,255,255,0.1);
      border-left-color: rgba(255,255,255,0.3);
    }
    
    .tab-content-container {
      flex: 1;
      overflow-y: auto;
      max-height: 400px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }

    /* Feature Controls */
    .feature-control {
      margin-bottom: 15px;
      padding: 12px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .feature-control h4 {
      margin-bottom: 10px;
      color: var(--accent);
      font-size: 1em;
    }
    
    .feature-control label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9em;
    }
    
    .feature-control input, 
    .feature-control select {
      width: 100%;
      margin-bottom: 8px;
    }
    
    .feature-control input[type="range"] {
      margin-bottom: 5px;
    }
    
    .feature-control-value {
      float: right;
      font-weight: 700;
      color: var(--accent);
    }

    /* Frame Grid */
    .frame-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .frame-option {
      padding: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .frame-option:hover {
      background: rgba(0,188,212,0.3);
    }
    
    .frame-option.active {
      background: rgba(0,188,212,0.5);
      border: 1px solid var(--accent);
    }

    /* Text Style Grid */
    .text-style-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .text-style-option {
      padding: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .text-style-option:hover {
      background: rgba(0,188,212,0.3);
    }
    
    .text-style-option.active {
      background: rgba(0,188,212,0.5);
      border: 1px solid var(--accent);
    }

    /* Sticker Grid */
    .sticker-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .sticker-item {
      font-size: 24px;
      text-align: center;
      padding: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .sticker-item:hover {
      background: rgba(0,188,212,0.2);
      transform: scale(1.1);
    }

    /* Advanced Controls */
    .advanced-control {
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      border-left: 3px solid var(--accent);
    }
    
    .advanced-control h4 {
      margin-bottom: 8px;
      color: var(--text-light);
      font-size: 0.95em;
    }

    /* Animation */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ===== Season Effects Overlay ===== */
    .season-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
      opacity: 0;
      transition: opacity 1.5s ease-in-out;
    }

    .season-overlay.active {
      opacity: 1;
    }

    /* Spring - Sakura Petals */
    .season-overlay.spring {
      background: linear-gradient(
        135deg,
        rgba(255, 182, 193, 0.3) 0%,
        rgba(255, 192, 203, 0.2) 30%,
        rgba(255, 240, 245, 0.1) 70%,
        transparent 100%
      );
    }

    .petal {
      position: absolute;
      width: 15px;
      height: 15px;
      background: linear-gradient(45deg, #FFB6C1, #FFC0CB);
      border-radius: 150% 0 150% 0;
      animation: fall 10s infinite linear;
      box-shadow: 0 0 10px rgba(255, 182, 193, 0.8);
    }

    @keyframes fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* Summer - Fireflies & Warm Glow */
    .season-overlay.summer {
      background: radial-gradient(
        circle at 50% 50%,
        rgba(255, 215, 0, 0.1) 0%,
        rgba(255, 140, 0, 0.1) 30%,
        transparent 70%
      );
    }

    .firefly {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #FFFF00;
      border-radius: 50%;
      box-shadow: 0 0 10px #FFFF00, 0 0 20px #FFD700;
      animation: float 8s infinite ease-in-out;
    }

    @keyframes float {
      0%, 100% {
        transform: translateY(0) translateX(0);
      }
      25% {
        transform: translateY(-50px) translateX(30px);
      }
      50% {
        transform: translateY(-20px) translateX(-20px);
      }
      75% {
        transform: translateY(-80px) translateX(10px);
      }
    }

    /* Autumn - Falling Leaves */
    .season-overlay.autumn {
      background: linear-gradient(
        45deg,
        rgba(255, 140, 0, 0.2) 0%,
        rgba(139, 69, 19, 0.15) 40%,
        rgba(205, 133, 63, 0.1) 80%,
        transparent 100%
      );
    }

    .leaf {
      position: absolute;
      width: 20px;
      height: 20px;
      animation: fall 12s infinite linear;
    }

    .leaf::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, #FF8C00, #CD853F);
      clip-path: polygon(50% 0%, 0% 100%, 50% 80%, 100% 100%);
      transform: rotate(45deg);
    }

    /* Winter - Snow & Frost */
    .season-overlay.winter {
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.1) 0%,
        rgba(240, 248, 255, 0.05) 50%,
        rgba(230, 230, 250, 0.05) 100%
      );
    }

    .snowflake {
      position: absolute;
      color: white;
      font-size: 1em;
      animation: snowfall 8s infinite linear;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
    }

    @keyframes snowfall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* Season Indicator */
    .season-indicator {
      position: fixed;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 15px 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1000;
    }

    .season-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }

    .season-dot.active {
      transform: scale(1.3);
      border-color: white;
      box-shadow: 0 0 10px currentColor;
    }

    .season-dot.spring { background: #FFB6C1; }
    .season-dot.summer { background: #FFD700; }
    .season-dot.autumn { background: #FF8C00; }
    .season-dot.winter { background: #87CEEB; }

    /* Season Info Tooltip */
    .season-info {
      position: fixed;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,150,200,0.4);
      backdrop-filter: blur(5px);
      color: white;
      padding: 5px 20px;
      border-radius: 2px;
      font-size: 0.9em;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }

    /* Compare Button */
    .compare-btn {
      position: fixed;
      bottom: 70px;
      right: 20px;
      background: rgba(0, 188, 212, 0.7);
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      transition: all 0.3s ease;
    }

    .compare-btn:hover {
      background: rgba(0, 188, 212, 0.9);
      transform: scale(1.1);
    }

    .compare-btn.active {
      background: rgba(244, 67, 54, 0.7);
    }

    .compare-btn.active:hover {
      background: rgba(244, 67, 54, 0.9);
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .season-indicator {
        top: auto;
        bottom: 20px;
        right: 50%;
        transform: translateX(50%);
        flex-direction: row;
        padding: 10px 15px;
      }
      
      .tab-container {
        flex-direction: row;
        flex-wrap: wrap;
        border-bottom: none;
        border-right: 1px solid rgba(255,255,255,0.1);
        margin-right: 15px;
        margin-bottom: 0;
        width: auto;
        max-width: 100%;
      }
      
      .tab {
        border-left: none;
        border-bottom: 3px solid transparent;
        border-radius: 8px 8px 0 0;
        white-space: nowrap;
        flex: 1 0 auto;
        min-width: 80px;
        text-align: center;
      }
      
      .tab.active {
        border-left: none;
        border-bottom-color: var(--accent);
      }
      
      .compare-btn {
        bottom: 80px;
        right: 15px;
        width: 45px;
        height: 45px;
      }
    }

    @media (max-width: 768px) {
      .panel { 
        grid-template-columns: 1fr; 
        gap: 25px; 
        padding: 25px 20px; 
      }
      h1 { 
        font-size: 2em; 
        text-align: center;
      }
      .info-content { 
        grid-template-columns: 1fr; 
      }
      .preview-wrapper {
        min-height: 300px;
      }
    }
    
    /* Mini Social Bar */
    .social-mini {
      position: fixed;
      bottom: 10px;
      right: 10px;
      display: flex;
      gap: 5px;
      z-index: 1000;
    }
    
    .social-mini-icon {
      width: 25px;
      height: 25px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      text-decoration: none;
      font-size: 10px;
      transition: all 0.2s ease;
    }
    
    .social-mini-icon:hover {
      background: var(--accent);
      transform: scale(1.1);
    }
    
    /* Mobile */
    @media (max-width: 768px) {
      .social-mini {
        bottom: 5px;
        right: 5px;
        gap: 3px;
      }
      
      .social-mini-icon {
        width: 20px;
        height: 20px;
        font-size: 8px;
      }
    }
    
    .emoji {
  background: none !important;
  -webkit-background-clip: unset !important;
  color: gold; /* bebas atur warna */
}

.info-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s ease, opacity 0.3s ease;
  opacity: 0;
  display: grid; /* biar layout tetap grid */
}
.info-content.active {
  max-height: 500px; /* cukup besar untuk isi panel */
  opacity: 1;
}
  </style>
</head>
<body>
  <!-- Season Overlays -->
  <div class="season-overlay" id="seasonOverlay"></div>
  
  <!-- Season Indicator -->
  <div class="season-indicator">
    <div class="season-dot spring active" data-season="spring" title="Spring - Sakura"></div>
    <div class="season-dot summer" data-season="summer" title="Summer - Fireflies"></div>
    <div class="season-dot autumn" data-season="autumn" title="Autumn - Momiji"></div>
    <div class="season-dot winter" data-season="winter" title="Winter - Snow"></div>
  </div>

  <!-- Season Info Original -->
  <div class="season-info" id="seasonInfo">Loading...</div>

  <h1>
  ubah gambar jadi 8k/32p 
  <span class="emoji">😹</span>
</h1>

  <div id="toast"><i class="fas fa-check-circle"></i> Upload berhasil!</div>

  <div class="panel">
    <div class="controls">
      <div class="control-group">
        <label>
          <i class="fas fa-cloud-upload-alt"></i> Upload Gambar
          <input type="file" id="imageUpload" accept="image/*">
        </label>
      </div>

      <div class="control-group">
        <div class="control-group-title"><i class="fas fa-sliders-h"></i> Pengaturan Dasar</div>
        <label>
          Resolusi Output: <span id="sizeVal">100</span>%
          <input type="range" id="sizeRange" min="1" max="200" value="100">
        </label>
        
        <label>
          Kualitas Output: <span id="qualityVal">92</span>%
          <input type="range" id="qualityRange" min="10" max="100" value="92">
        </label>
      </div>

      <div class="control-group">
        <div class="control-group-title"><i class="fas fa-magic"></i> Filter & Efek</div>
        
        <div class="tab-layout">
          <div class="tab-container">
            <div class="tab active" data-tab="basic">Basic</div>
            <div class="tab" data-tab="artistic">Artistic</div>
            <div class="tab" data-tab="distortion">Distortion</div>
            <div class="tab" data-tab="color">Color</div>
            <div class="tab" data-tab="cyberfunk">Cyber Funk</div>
            <div class="tab" data-tab="adjustments">Adjustments</div>
            <div class="tab" data-tab="frames">Frames</div>
            <div class="tab" data-tab="text">Text</div>
            <div class="tab" data-tab="stickers">Stickers</div>
            <div class="tab" data-tab="advanced">Advanced</div>
          </div>
          
          <div class="tab-content-container">
            <!-- Tab Basic -->
            <div class="tab-content active" id="basic-tab">
              <select id="mode">
                <option value="resize">Resize Biasa</option>
                <option value="noise">Noise Glitch</option>
                <option value="rgb">RGB Shift</option>
                <option value="vhs">VHS Tracking</option>
                <option value="invert">Invert Colors</option>
                <option value="ghost">Ghost Echo</option>
                <option value="pixelate">Pixelate</option>
                <option value="sepia">Sepia Rusak</option>
                <option value="oversat">Over Saturation</option>
                <option value="graynoise">Grayscale Noise</option>
                <option value="scanline">Scanline CRT</option>
                <option value="burned">Burned Contrast</option>
                <option value="swap">Random Color Swap</option>
              </select>
            </div>
            
            <!-- Tab Artistic -->
            <div class="tab-content" id="artistic-tab">
              <select id="artisticMode">
                <option value="none">Pilih Efek Artistik</option>
                <option value="watercolor">Watercolor</option>
                <option value="oilpainting">Oil Painting</option>
                <option value="sketch">Pencil Sketch</option>
                <option value="pointillism">Pointillism</option>
                <option value="halftone">Halftone Dots</option>
                <option value="crosshatch">Cross Hatch</option>
                <option value="mosaic">Mosaic Tiles</option>
                <option value="stainedglass">Stained Glass</option>
              </select>
            </div>
            
            <!-- Tab Distortion -->
            <div class="tab-content" id="distortion-tab">
              <select id="distortionMode">
                <option value="none">Pilih Distorsi</option>
                <option value="ripple">Ripple Effect</option>
                <option value="bulge">Bulge Effect</option>
                <option value="pinch">Pinch Effect</option>
                <option value="swirl">Swirl Effect</option>
                <option value="fisheye">Fisheye Lens</option>
                <option value="kaleidoscope">Kaleidoscope</option>
                <option value="mirror">Mirror Effect</option>
                <option value="tunnel">Tunnel Vision</option>
              </select>
            </div>
            
            <!-- Tab Color -->
            <div class="tab-content" id="color-tab">
              <select id="colorMode">
                <option value="none">Pilih Efek Warna</option>
                <option value="duotone">Duotone</option>
                <option value="posterize">Posterize</option>
                <option value="solarize">Solarize</option>
                <option value="edgeglow">Edge Glow</option>
                <option value="chromatic">Chromatic Aberration</option>
                <option value="thermal">Thermal Vision</option>
                <option value="xray">X-Ray</option>
                <option value="infrared">Infrared</option>
              </select>
            </div>

            <!-- Tab Cyber Funk -->
            <div class="tab-content" id="cyberfunk-tab">
              <select id="cyberfunkMode">
                <option value="none">Pilih Efek Cyber Funk</option>
                <option value="neonglow">Neon Glow</option>
                <option value="cybergrid">Cyber Grid</option>
                <option value="hologram">Hologram</option>
                <option value="digitalglitch">Digital Glitch</option>
                <option value="synthwave">Synthwave</option>
                <option value="cyberpunk">Cyberpunk</option>
                <option value="neonrain">Neon Rain</option>
              </select>
            </div>
            
            <!-- Tab Adjustments -->
            <div class="tab-content" id="adjustments-tab">
              <div class="feature-control">
                <h4><i class="fas fa-sun"></i> Brightness</h4>
                <label>Level: <span class="feature-control-value" id="brightnessValue">0</span></label>
                <input type="range" id="brightness" min="-100" max="100" value="0">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-adjust"></i> Contrast</h4>
                <label>Level: <span class="feature-control-value" id="contrastValue">0</span></label>
                <input type="range" id="contrast" min="-100" max="100" value="0">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-tint"></i> Saturation</h4>
                <label>Level: <span class="feature-control-value" id="saturationValue">0</span></label>
                <input type="range" id="saturation" min="-100" max="100" value="0">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-eye"></i> Exposure</h4>
                <label>Level: <span class="feature-control-value" id="exposureValue">0</span></label>
                <input type="range" id="exposure" min="-100" max="100" value="0">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-thermometer-half"></i> Temperature</h4>
                <label>Level: <span class="feature-control-value" id="temperatureValue">0</span></label>
                <input type="range" id="temperature" min="-100" max="100" value="0">
              </div>
            </div>

            <!-- Tab Frames -->
            <div class="tab-content" id="frames-tab">
              <div class="feature-control">
                <h4><i class="fas fa-border-style"></i> Frame Style</h4>
                <div class="frame-grid">
                  <div class="frame-option active" data-frame="none">None</div>
                  <div class="frame-option" data-frame="simple">Simple</div>
                  <div class="frame-option" data-frame="vintage">Vintage</div>
                  <div class="frame-option" data-frame="modern">Modern</div>
                  <div class="frame-option" data-frame="polaroid">Polaroid</div>
                  <div class="frame-option" data-frame="film">Film Strip</div>
                </div>
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-expand-arrows-alt"></i> Frame Size</h4>
                <label>Thickness: <span class="feature-control-value" id="frameSizeValue">10</span>px</label>
                <input type="range" id="frameSize" min="1" max="50" value="10">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-palette"></i> Frame Color</h4>
                <input type="color" id="frameColor" value="#ffffff">
              </div>
            </div>
            
            <!-- Tab Text -->
            <div class="tab-content" id="text-tab">
              <div class="feature-control">
                <h4><i class="fas fa-font"></i> Text Content</h4>
                <input type="text" id="textContent" placeholder="Enter your text here">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-text-height"></i> Text Style</h4>
                <div class="text-style-grid">
                  <div class="text-style-option active" data-style="normal">Normal</div>
                  <div class="text-style-option" data-style="bold">Bold</div>
                  <div class="text-style-option" data-style="italic">Italic</div>
                  <div class="text-style-option" data-style="outline">Outline</div>
                </div>
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-text-width"></i> Font Size</h4>
                <label>Size: <span class="feature-control-value" id="fontSizeValue">24</span>px</label>
                <input type="range" id="fontSize" min="10" max="100" value="24">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-palette"></i> Text Color</h4>
                <input type="color" id="textColor" value="#ffffff">
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-arrows-alt"></i> Text Position</h4>
                <select id="textPosition">
                  <option value="top-left">Top Left</option>
                  <option value="top-center">Top Center</option>
                  <option value="top-right">Top Right</option>
                  <option value="center">Center</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-center">Bottom Center</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>
            </div>
            
            <!-- Tab Stickers -->
            <div class="tab-content" id="stickers-tab">
              <div class="feature-control">
                <h4><i class="fas fa-icons"></i> Emoji Stickers</h4>
                <div class="sticker-grid">
                  <div class="sticker-item" data-sticker="😀">😀</div>
                  <div class="sticker-item" data-sticker="😂">😂</div>
                  <div class="sticker-item" data-sticker="😍">😍</div>
                  <div class="sticker-item" data-sticker="🤩">🤩</div>
                  <div class="sticker-item" data-sticker="😎">😎</div>
                  <div class="sticker-item" data-sticker="🥳">🥳</div>
                  <div class="sticker-item" data-sticker="😭">😭</div>
                  <div class="sticker-item" data-sticker="😡">😡</div>
                  <div class="sticker-item" data-sticker="👍">👍</div>
                  <div class="sticker-item" data-sticker="👎">👎</div>
                  <div class="sticker-item" data-sticker="👏">👏</div>
                  <div class="sticker-item" data-sticker="🙏">🙏</div>
                </div>
              </div>
              
              <div class="feature-control">
                <h4><i class="fas fa-expand-arrows-alt"></i> Sticker Size</h4>
                <label>Size: <span class="feature-control-value" id="stickerSizeValue">50</span>px</label>
                <input type="range" id="stickerSize" min="20" max="200" value="50">
              </div>
            </div>
            
            <!-- Tab Advanced -->
            <div class="tab-content" id="advanced-tab">
              <div class="advanced-control">
                <h4><i class="fas fa-blur"></i> Blur & Sharpen</h4>
                <label>Blur: <span class="feature-control-value" id="blurValue">0</span>px</label>
                <input type="range" id="blur" min="0" max="20" value="0">
                
                <label>Sharpen: <span class="feature-control-value" id="sharpenValue">0</span></label>
                <input type="range" id="sharpen" min="0" max="100" value="0">
              </div>
              
              <div class="advanced-control">
                <h4><i class="fas fa-magic"></i> Noise Reduction</h4>
                <label>Level: <span class="feature-control-value" id="noiseReductionValue">0</span></label>
                <input type="range" id="noiseReduction" min="0" max="100" value="0">
              </div>
              
              <div class="advanced-control">
                <h4><i class="fas fa-crop"></i> Crop Tool</h4>
                <button id="cropTool"><i class="fas fa-crop-alt"></i> Enable Crop</button>
              </div>
              
              <div class="advanced-control">
                <h4><i class="fas fa-redo"></i> Perspective Correction</h4>
                <label>Horizontal: <span class="feature-control-value" id="perspectiveHValue">0</span></label>
                <input type="range" id="perspectiveH" min="-45" max="45" value="0">
                
                <label>Vertical: <span class="feature-control-value" id="perspectiveVValue">0</span></label>
                <input type="range" id="perspectiveV" min="-45" max="45" value="0">
              </div>
            </div>
          </div>
        </div>

        <!-- Filter controls container -->
        <div id="filterControlsContainer">
          <!-- Noise Glitch Controls -->
          <div id="noiseControls" class="filter-controls">
            <div class="filter-control">
              <label>Jumlah Noise: <span class="filter-control-value" id="noiseAmountValue">40</span></label>
              <input type="range" id="noiseAmount" min="0" max="100" value="40">
            </div>
          </div>

          <!-- RGB Shift Controls -->
          <div id="rgbControls" class="filter-controls">
            <div class="filter-control">
              <label>Jumlah RGB Shift: <span class="filter-control-value" id="rgbShiftAmountValue">15</span></label>
              <input type="range" id="rgbShiftAmount" min="0" max="50" value="15">
            </div>
          </div>
          
          <!-- VHS Tracking Controls -->
          <div id="vhsControls" class="filter-controls">
            <div class="filter-control">
              <label>Distorsi VHS: <span class="filter-control-value" id="vhsDistortionValue">10</span></label>
              <input type="range" id="vhsDistortion" min="0" max="20" value="10">
            </div>
          </div>
          
          <!-- Ghost Echo Controls -->
          <div id="ghostControls" class="filter-controls">
            <div class="filter-control">
              <label>Jumlah Echo: <span class="filter-control-value" id="ghostCountValue">2</span></label>
              <input type="range" id="ghostCount" min="1" max="5" value="2">
            </div>
            <div class="filter-control">
              <label>Opacity Echo: <span class="filter-control-value" id="ghostOpacityValue">25</span>%</label>
              <input type="range" id="ghostOpacity" min="5" max="50" value="25">
            </div>
          </div>
          
          <!-- Pixelate Controls -->
          <div id="pixelateControls" class="filter-controls">
            <div class="filter-control">
              <label>Ukuran Pixel: <span class="filter-control-value" id="pixelSizeValue">8</span>px</label>
              <input type="range" id="pixelSize" min="2" max="20" value="8">
            </div>
          </div>
          
          <!-- Over Saturation Controls -->
          <div id="oversatControls" class="filter-controls">
            <div class="filter-control">
              <label>Jumlah Saturasi: <span class="filter-control-value" id="saturationAmountValue">1.6</span>x</label>
              <input type="range" id="saturationAmount" min="1" max="3" step="0.1" value="1.6">
            </div>
          </div>
          
          <!-- Grayscale Noise Controls -->
          <div id="graynoiseControls" class="filter-controls">
            <div class="filter-control">
              <label>Jumlah Noise: <span class="filter-control-value" id="graynoiseAmountValue">50</span></label>
              <input type="range" id="graynoiseAmount" min="0" max="100" value="50">
            </div>
          </div>
          
          <!-- Scanline CRT Controls -->
          <div id="scanlineControls" class="filter-controls">
            <div class="filter-control">
              <label>Ukuran Scanline: <span class="filter-control-value" id="scanlineSizeValue">4</span>px</label>
              <input type="range" id="scanlineSize" min="1" max="8" value="4">
            </div>
            <div class="filter-control">
              <label>Opacity Scanline: <span class="filter-control-value" id="scanlineOpacityValue">30</span>%</label>
              <input type="range" id="scanlineOpacity" min="10" max="70" value="30">
            </div>
          </div>
          
          <!-- Burned Contrast Controls -->
          <div id="burnedControls" class="filter-controls">
            <div class="filter-control">
              <label>Jumlah Kontras: <span class="filter-control-value" id="burnedAmountValue">1.8</span>x</label>
              <input type="range" id="burnedAmount" min="1" max="3" step="0.1" value="1.8">
            </div>
          </div>
          
          <!-- Watercolor Controls -->
          <div id="watercolorControls" class="filter-controls">
            <div class="filter-control">
              <label>Brush Size: <span class="filter-control-value" id="watercolorBrushValue">8</span></label>
              <input type="range" id="watercolorBrush" min="3" max="15" value="8">
            </div>
            <div class="filter-control">
              <label>Intensity: <span class="filter-control-value" id="watercolorIntensityValue">70</span>%</label>
              <input type="range" id="watercolorIntensity" min="20" max="100" value="70">
            </div>
          </div>
          
          <!-- Oil Painting Controls -->
          <div id="oilpaintingControls" class="filter-controls">
            <div class="filter-control">
              <label>Brush Size: <span class="filter-control-value" id="oilBrushValue">5</span></label>
              <input type="range" id="oilBrush" min="1" max="10" value="5">
            </div>
            <div class="filter-control">
              <label>Intensity: <span class="filter-control-value" id="oilIntensityValue">60</span>%</label>
              <input type="range" id="oilIntensity" min="10" max="100" value="60">
            </div>
          </div>
          
          <!-- Sketch Controls -->
          <div id="sketchControls" class="filter-controls">
            <div class="filter-control">
              <label>Pencil Size: <span class="filter-control-value" id="sketchPencilValue">1</span></label>
              <input type="range" id="sketchPencil" min="1" max="5" step="0.5" value="1">
            </div>
            <div class="filter-control">
              <label>Darkness: <span class="filter-control-value" id="sketchDarknessValue">70</span>%</label>
              <input type="range" id="sketchDarkness" min="30" max="100" value="70">
            </div>
          </div>
          
          <!-- Ripple Controls -->
          <div id="rippleControls" class="filter-controls">
            <div class="filter-control">
              <label>Wave Size: <span class="filter-control-value" id="rippleSizeValue">20</span></label>
              <input type="range" id="rippleSize" min="5" max="50" value="20">
            </div>
            <div class="filter-control">
              <label>Frequency: <span class="filter-control-value" id="rippleFreqValue">0.05</span></label>
              <input type="range" id="rippleFreq" min="0.01" max="0.1" step="0.01" value="0.05">
            </div>
          </div>
          
          <!-- Duotone Controls -->
          <div id="duotoneControls" class="filter-controls">
            <div class="filter-control">
              <label>Dark Color</label>
              <input type="color" id="duotoneDark" value="#0000ff">
            </div>
            <div class="filter-control">
              <label>Light Color</label>
              <input type="color" id="duotoneLight" value="#ffff00">
            </div>
          </div>
          
          <!-- Cyber Funk Controls -->
          <div id="neonglowControls" class="filter-controls">
            <div class="filter-control">
              <label>Neon Color</label>
              <input type="color" id="neonColor" value="#ff00ff">
            </div>
            <div class="filter-control">
              <label>Glow Intensity: <span class="filter-control-value" id="glowIntensityValue">80</span>%</label>
              <input type="range" id="glowIntensity" min="0" max="100" value="80">
            </div>
          </div>
          
          <div id="cybergridControls" class="filter-controls">
            <div class="filter-control">
              <label>Grid Size: <span class="filter-control-value" id="gridSizeValue">20</span>px</label>
              <input type="range" id="gridSize" min="5" max="50" value="20">
            </div>
            <div class="filter-control">
              <label>Grid Color</label>
              <input type="color" id="gridColor" value="#00ffff">
            </div>
          </div>
          
          <div id="hologramControls" class="filter-controls">
            <div class="filter-control">
              <label>Interference: <span class="filter-control-value" id="interferenceValue">50</span>%</label>
              <input type="range" id="interference" min="0" max="100" value="50">
            </div>
            <div class="filter-control">
              <label>Transparency: <span class="filter-control-value" id="transparencyValue">70</span>%</label>
              <input type="range" id="transparency" min="0" max="100" value="70">
            </div>
          </div>
          
          <div id="digitalglitchControls" class="filter-controls">
            <div class="filter-control">
              <label>Glitch Amount: <span class="filter-control-value" id="glitchAmountValue">30</span>%</label>
              <input type="range" id="glitchAmount" min="0" max="100" value="30">
            </div>
            <div class="filter-control">
              <label>Color Shift: <span class="filter-control-value" id="colorShiftValue">15</span>px</label>
              <input type="range" id="colorShift" min="0" max="50" value="15">
            </div>
          </div>

          <div id="synthwaveControls" class="filter-controls">
            <div class="filter-control">
              <label>Sun Color</label>
              <input type="color" id="sunColor" value="#ff00aa">
            </div>
            <div class="filter-control">
              <label>Horizon Height: <span class="filter-control-value" id="horizonHeightValue">60</span>%</label>
              <input type="range" id="horizonHeight" min="0" max="100" value="60">
            </div>
          </div>
          
          <div id="cyberpunkControls" class="filter-controls">
            <div class="filter-control">
              <label>Accent Color</label>
              <input type="color" id="accentColor" value="#00ff00">
            </div>
            <div class="filter-control">
              <label>Darkness: <span class="filter-control-value" id="darknessValue">40</span>%</label>
              <input type="range" id="darkness" min="0" max="100" value="40">
            </div>
          </div>
          
          <div id="neonrainControls" class="filter-controls">
            <div class="filter-control">
              <label>Rain Density: <span class="filter-control-value" id="rainDensityValue">50</span>%</label>
              <input type="range" id="rainDensity" min="0" max="100" value="50">
            </div>
            <div class="filter-control">
              <label>Rain Color</label>
              <input type="color" id="rainColor" value="#ff00ff">
            </div>
          </div>
        </div>
      </div>

      <div class="control-group">
        <button id="downloadBtn" disabled><i class="fas fa-download"></i> Download Image</button>
        <button id="resetBtn"><i class="fas fa-undo"></i> Reset All</button>
      </div>

      <div class="info-panel">
        <div class="info-header">
          <span><i class="fas fa-info-circle"></i> Informasi Media</span>
          <i class="fas fa-chevron-down"></i>
        </div>
        <div class="info-content">
          <div class="info-card"><span id="oriDim">-</span><small>Dimensi Asli</small></div>
          <div class="info-card"><span id="oriSize">-</span><small>Ukuran File Asli</small></div>
          <div class="info-card"><span id="outDim">-</span><small>Resolusi Output</small></div>
          <div class="info-card"><span id="outSize">-</span><small>Ukuran File Output</small></div>
          <div class="info-card"><span id="outMode">-</span><small>Mode Terpilih</small></div>
          <div class="info-card"><span id="ratio">-</span><small>Perubahan Ukuran</small></div>
        </div>
      </div>
    </div>

    <div class="preview-wrapper">
      <img id="preview"/>
      <canvas id="canvas"></canvas>
      <div class="placeholder-text" id="placeholder">
        <i class="fas fa-image"></i>
        <p>Upload gambar untuk memulai editing</p>
      </div>
    </div>
  </div>
  
  <!-- Compare Button -->
  <button class="compare-btn" id="compareBtn" title="Compare Original vs Edited">
    <i class="fas fa-exchange-alt"></i>
  </button>
  
  <!-- Compact Social Bar -->
  <div class="social-mini">
    <a href="https://facebook.com" target="_blank" class="social-mini-icon" title="Facebook">
      <i class="fab fa-facebook-f"></i>
    </a>
    <a href="https://twitter.com" target="_blank" class="social-mini-icon" title="Twitter">
      <i class="fab fa-twitter"></i>
    </a>
    <a href="https://instagram.com" target="_blank" class="social-mini-icon" title="Instagram">
      <i class="fab fa-instagram"></i>
    </a>
  </div>

  <script>
    // Variabel global
    let originalImage = null;
    let currentImage = null;
    let isComparing = false;
    let compareInterval = null;
    let activeTab = 'basic';
    let activeMode = 'resize';
    let selectedSticker = null;
    let stickerPosition = { x: 0, y: 0 };
    
        // Inisialisasi saat DOM dimuat
    document.addEventListener('DOMContentLoaded', function() {
      // Fungsi untuk mendapatkan musim berdasarkan bulan di Jepang
      function getJapanSeason() {
        const now = new Date();
        const month = now.getMonth() + 1; // getMonth() mengembalikan 0-11
        
        if (month >= 3 && month <= 5) {
          return 'spring'; // Maret-Mei: Musim Semi (Sakura)
        } else if (month >= 6 && month <= 8) {
          return 'summer'; // Juni-Agustus: Musim Panas
        } else if (month >= 9 && month <= 11) {
          return 'autumn'; // September-November: Musim Gugur (Momiji)
        } else {
          return 'winter'; // Desember-Februari: Musim Dingin
        }
      }
      
      // Mengatur musim aktif berdasarkan musim di Jepang
      function setJapanSeason() {
        const currentSeason = getJapanSeason();
        
        // Hapus kelas aktif dari semua indikator musim
        document.querySelectorAll('.season-dot').forEach(dot => {
          dot.classList.remove('active');
        });
        
        // Tambahkan kelas aktif ke musim yang sesuai
        document.querySelector(`.season-dot[data-season="${currentSeason}"]`).classList.add('active');
        
        // Terapkan overlay musim
        const overlay = document.getElementById('seasonOverlay');
        overlay.className = 'season-overlay ' + currentSeason;
        overlay.classList.add('active');
        
        // Update teks informasi musim
        const seasonNames = {
          'spring': 'Musim Semi - Sakura',
          'summer': 'Musim Panas - Fireflies',
          'autumn': 'Musim Gugur - Momiji',
          'winter': 'Musim Dingin - Snow'
        };
        document.getElementById('seasonInfo').textContent = seasonNames[currentSeason];
        
        // Buat efek musim
        createSeasonEffects(currentSeason);
      }
      
      // Fungsi untuk membuat efek musim
      function createSeasonEffects(season) {
        const overlay = document.getElementById('seasonOverlay');
        
        // Hapus efek yang ada
        overlay.innerHTML = '';
        
        if (season === 'spring') {
          // Buat efek sakura petals
          for (let i = 0; i < 15; i++) {
            const petal = document.createElement('div');
            petal.className = 'petal';
            petal.style.left = Math.random() * 100 + '%';
            petal.style.animationDelay = Math.random() * 10 + 's';
            petal.style.animationDuration = (Math.random() * 10 + 10) + 's';
            overlay.appendChild(petal);
          }
        } else if (season === 'summer') {
          // Buat efek fireflies
          for (let i = 0; i < 20; i++) {
            const firefly = document.createElement('div');
            firefly.className = 'firefly';
            firefly.style.left = Math.random() * 100 + '%';
            firefly.style.top = Math.random() * 100 + '%';
            firefly.style.animationDelay = Math.random() * 5 + 's';
            firefly.style.animationDuration = (Math.random() * 5 + 5) + 's';
            overlay.appendChild(firefly);
          }
        } else if (season === 'autumn') {
          // Buat efek falling leaves
          for (let i = 0; i < 15; i++) {
            const leaf = document.createElement('div');
            leaf.className = 'leaf';
            leaf.style.left = Math.random() * 100 + '%';
            leaf.style.animationDelay = Math.random() * 10 + 's';
            leaf.style.animationDuration = (Math.random() * 10 + 10) + 's';
            
            // Warna daun acak
            const colors = ['#FF8C00', '#CD853F', '#D2691E', '#A0522D'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            leaf.style.setProperty('--leaf-color', randomColor);
            
            overlay.appendChild(leaf);
          }
        } else if (season === 'winter') {
          // Buat efek snowflakes
          for (let i = 0; i < 30; i++) {
            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.innerHTML = '❄';
            snowflake.style.left = Math.random() * 100 + '%';
            snowflake.style.animationDelay = Math.random() * 10 + 's';
            snowflake.style.animationDuration = (Math.random() * 10 + 10) + 's';
            snowflake.style.fontSize = (Math.random() * 10 + 10) + 'px';
            overlay.appendChild(snowflake);
          }
        }
      }
      
      // Inisialisasi musim Jepang
      setJapanSeason();
      
      // Event listener untuk indikator musim
      document.querySelectorAll('.season-dot').forEach(dot => {
        dot.addEventListener('click', function() {
          const season = this.getAttribute('data-season');
          
          // Hapus kelas aktif dari semua indikator
          document.querySelectorAll('.season-dot').forEach(d => {
            d.classList.remove('active');
          });
          
          // Tambahkan kelas aktif ke yang diklik
          this.classList.add('active');
          
          // Terapkan overlay musim
          const overlay = document.getElementById('seasonOverlay');
          overlay.className = 'season-overlay ' + season;
          overlay.classList.add('active');
          
          // Update teks informasi musim
          const seasonNames = {
            'spring': 'Musim Semi - Sakura',
            'summer': 'Musim Panas - Fireflies',
            'autumn': 'Musim Gugur - Momiji',
            'winter': 'Musim Dingin - Snow'
          };
          document.getElementById('seasonInfo').textContent = seasonNames[season];
          
          // Buat efek musim
          createSeasonEffects(season);
        });
      });
      
      // Event listener untuk upload gambar
      document.getElementById('imageUpload').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
              // Simpan gambar asli
              originalImage = img;
              currentImage = img;
              
              // Tampilkan gambar di preview
              document.getElementById('preview').src = event.target.result;
              document.getElementById('preview').style.display = 'block';
              document.getElementById('placeholder').style.display = 'none';
              
              // Update informasi gambar
              updateImageInfo(img, file);
              
              // Terapkan filter dan resize awal
              applyFiltersAndResize();
              
              // Aktifkan tombol download
              document.getElementById('downloadBtn').disabled = false;
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      });
      
      // Event listener untuk perubahan resolusi
      document.getElementById('sizeRange').addEventListener('input', function() {
        document.getElementById('sizeVal').textContent = this.value;
        applyFiltersAndResize();
      });
      
      // Event listener untuk perubahan kualitas
      document.getElementById('qualityRange').addEventListener('input', function() {
        document.getElementById('qualityVal').textContent = this.value;
        // Kualitas hanya berpengaruh saat menyimpan, jadi tidak perlu applyFiltersAndResize di sini
      });
      
      // Event listener untuk tab
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', function() {
          // Hapus kelas aktif dari semua tab
          document.querySelectorAll('.tab').forEach(t => {
            t.classList.remove('active');
          });
          
          // Tambahkan kelas aktif ke tab yang diklik
          this.classList.add('active');
          
          // Sembunyikan semua konten tab
          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
          });
          
          // Tampilkan konten tab yang sesuai
          const tabId = this.getAttribute('data-tab');
          document.getElementById(tabId + '-tab').classList.add('active');
          
          // Simpan tab aktif
          activeTab = tabId;
        });
      });
      
      // Event listener untuk mode filter
      document.getElementById('mode').addEventListener('change', function() {
        // Sembunyikan semua kontrol filter
        document.querySelectorAll('.filter-controls').forEach(control => {
          control.classList.remove('active');
        });
        
        // Tampilkan kontrol filter yang sesuai
        const selectedMode = this.value;
        if (selectedMode && document.getElementById(selectedMode + 'Controls')) {
          document.getElementById(selectedMode + 'Controls').classList.add('active');
        }
        
        // Simpan mode aktif
        activeMode = selectedMode;
        
        // Terapkan filter
        applyFiltersAndResize();
      });
      
      // Event listener untuk mode artistic
      document.getElementById('artisticMode').addEventListener('change', function() {
        // Sembunyikan semua kontrol filter
        document.querySelectorAll('.filter-controls').forEach(control => {
          control.classList.remove('active');
        });
        
        // Tampilkan kontrol filter yang sesuai
        const selectedMode = this.value;
        if (selectedMode && selectedMode !== 'none' && document.getElementById(selectedMode + 'Controls')) {
          document.getElementById(selectedMode + 'Controls').classList.add('active');
        }
        
        // Simpan mode aktif
        activeMode = selectedMode;
        
        // Terapkan filter
        applyFiltersAndResize();
      });

      // Event listener untuk mode distortion
      document.getElementById('distortionMode').addEventListener('change', function() {
        // Sembunyikan semua kontrol filter
        document.querySelectorAll('.filter-controls').forEach(control => {
          control.classList.remove('active');
        });
        
        // Tampilkan kontrol filter yang sesuai
        const selectedMode = this.value;
        if (selectedMode && selectedMode !== 'none' && document.getElementById(selectedMode + 'Controls')) {
          document.getElementById(selectedMode + 'Controls').classList.add('active');
        }
        
        // Simpan mode aktif
        activeMode = selectedMode;
        
        // Terapkan filter
        applyFiltersAndResize();
      });
      
      // Event listener untuk mode color
      document.getElementById('colorMode').addEventListener('change', function() {
        // Sembunyikan semua kontrol filter
        document.querySelectorAll('.filter-controls').forEach(control => {
          control.classList.remove('active');
        });
        
        // Tampilkan kontrol filter yang sesuai
        const selectedMode = this.value;
        if (selectedMode && selectedMode !== 'none' && document.getElementById(selectedMode + 'Controls')) {
          document.getElementById(selectedMode + 'Controls').classList.add('active');
        }
        
        // Simpan mode aktif
        activeMode = selectedMode;
        
        // Terapkan filter
        applyFiltersAndResize();
      });
      
      // Event listener untuk mode cyberfunk
      document.getElementById('cyberfunkMode').addEventListener('change', function() {
        // Sembunyikan semua kontrol filter
        document.querySelectorAll('.filter-controls').forEach(control => {
          control.classList.remove('active');
        });
        
        // Tampilkan kontrol filter yang sesuai
        const selectedMode = this.value;
        if (selectedMode && selectedMode !== 'none' && document.getElementById(selectedMode + 'Controls')) {
          document.getElementById(selectedMode + 'Controls').classList.add('active');
        }
        
        // Simpan mode aktif
        activeMode = selectedMode;
        
        // Terapkan filter
        applyFiltersAndResize();
      });
      
      // Event listener untuk kontrol filter
      document.querySelectorAll('.filter-control input[type="range"]').forEach(input => {
        input.addEventListener('input', function() {
          // Update nilai tampilan
          const valueDisplay = document.getElementById(this.id + 'Value');
          if (valueDisplay) {
            let value = this.value;
            if (this.id === 'saturationAmount' || this.id === 'burnedAmount') {
              value = parseFloat(value).toFixed(1);
            }
            valueDisplay.textContent = value;
          }
          
          // Terapkan filter
          applyFiltersAndResize();
        });
      });
      
      // Event listener untuk frame options
      document.querySelectorAll('.frame-option').forEach(option => {
        option.addEventListener('click', function() {
          // Hapus kelas aktif dari semua opsi
          document.querySelectorAll('.frame-option').forEach(o => {
            o.classList.remove('active');
          });
          
          // Tambahkan kelas aktif ke opsi yang diklik
          this.classList.add('active');
          
          // Terapkan filter
          applyFiltersAndResize();
        });
      });
      
      // Event listener untuk text style options
      document.querySelectorAll('.text-style-option').forEach(option => {
        option.addEventListener('click', function() {
          // Hapus kelas aktif dari semua opsi
          document.querySelectorAll('.text-style-option').forEach(o => {
            o.classList.remove('active');
          });
          
          // Tambahkan kelas aktif ke opsi yang diklik
          this.classList.add('active');
          
          // Terapkan filter
          applyFiltersAndResize();
        });
      });
      
      // Event listener untuk sticker items
      document.querySelectorAll('.sticker-item').forEach(sticker => {
        sticker.addEventListener('click', function() {
          // Simpan sticker yang dipilih
          selectedSticker = this.getAttribute('data-sticker');
          
          // Hapus kelas aktif dari semua sticker
          document.querySelectorAll('.sticker-item').forEach(s => {
            s.classList.remove('active');
          });
          
          // Tambahkan kelas aktif ke sticker yang diklik
          this.classList.add('active');
          
          // Terapkan filter
          applyFiltersAndResize();
        });
      });
      
      // Event listener untuk kontrol di tab lainnya
      document.querySelectorAll('#brightness, #contrast, #saturation, #exposure, #temperature, #frameSize, #fontSize, #stickerSize, #blur, #sharpen, #noiseReduction, #perspectiveH, #perspectiveV').forEach(input => {
        input.addEventListener('input', function() {
          // Update nilai tampilan
          const valueDisplay = document.getElementById(this.id + 'Value');
          if (valueDisplay) {
            valueDisplay.textContent = this.value;
          }

          // Terapkan filter
          applyFiltersAndResize();
        });
      });
      
      // Event listener untuk color inputs
      document.querySelectorAll('#frameColor, #textColor, #duotoneDark, #duotoneLight, #neonColor, #gridColor, #sunColor, #accentColor, #rainColor').forEach(input => {
        input.addEventListener('input', function() {
          // Terapkan filter
          applyFiltersAndResize();
        });
      });
      
      // Event listener untuk selects di tab lainnya
      document.querySelectorAll('#textPosition').forEach(select => {
        select.addEventListener('change', function() {
          // Terapkan filter
          applyFiltersAndResize();
        });
      });
      
      // Event listener untuk tombol download
      document.getElementById('downloadBtn').addEventListener('click', function() {
        if (!originalImage) return;
        
        const canvas = document.getElementById('canvas');
        const quality = document.getElementById('qualityRange').value / 100;
        
        // Buat link download
        const link = document.createElement('a');
        link.download = 'edited-image.jpg';
        link.href = canvas.toDataURL('image/jpeg', quality);
        link.click();
        
        // Tampilkan toast
        showToast('Image downloaded successfully!');
      });
      
      // Event listener untuk tombol reset
      document.getElementById('resetBtn').addEventListener('click', function() {
        // Reset semua kontrol ke nilai default
        document.getElementById('sizeRange').value = 100;
        document.getElementById('sizeVal').textContent = '100';
        document.getElementById('qualityRange').value = 92;
        document.getElementById('qualityVal').textContent = '92';
        document.getElementById('mode').value = 'resize';
        document.getElementById('artisticMode').value = 'none';
        document.getElementById('distortionMode').value = 'none';
        document.getElementById('colorMode').value = 'none';
        document.getElementById('cyberfunkMode').value = 'none';
        
        // Reset kontrol adjustments
        document.getElementById('brightness').value = 0;
        document.getElementById('brightnessValue').textContent = '0';
        document.getElementById('contrast').value = 0;
        document.getElementById('contrastValue').textContent = '0';
        document.getElementById('saturation').value = 0;
        document.getElementById('saturationValue').textContent = '0';
        document.getElementById('exposure').value = 0;
        document.getElementById('exposureValue').textContent = '0';
        document.getElementById('temperature').value = 0;
        document.getElementById('temperatureValue').textContent = '0';
        
        // Reset frame
        document.querySelectorAll('.frame-option').forEach(option => {
          option.classList.remove('active');
        });
        document.querySelector('.frame-option[data-frame="none"]').classList.add('active');
        document.getElementById('frameSize').value = 10;
        document.getElementById('frameSizeValue').textContent = '10';
        document.getElementById('frameColor').value = '#ffffff';
        
        // Reset text
        document.getElementById('textContent').value = '';
        document.querySelectorAll('.text-style-option').forEach(option => {
          option.classList.remove('active');
        });
        document.querySelector('.text-style-option[data-style="normal"]').classList.add('active');
        document.getElementById('fontSize').value = 24;
        document.getElementById('fontSizeValue').textContent = '24';
        document.getElementById('textColor').value = '#ffffff';
        document.getElementById('textPosition').value = 'center';
        
        // Reset stickers
        document.querySelectorAll('.sticker-item').forEach(sticker => {
          sticker.classList.remove('active');
        });
        document.getElementById('stickerSize').value = 50;
        document.getElementById('stickerSizeValue').textContent = '50';
        selectedSticker = null;
        
        // Reset advanced
        document.getElementById('blur').value = 0;
        document.getElementById('blurValue').textContent = '0';
        document.getElementById('sharpen').value = 0;
        document.getElementById('sharpenValue').textContent = '0';
        document.getElementById('noiseReduction').value = 0;
        document.getElementById('noiseReductionValue').textContent = '0';
        document.getElementById('perspectiveH').value = 0;
        document.getElementById('perspectiveHValue').textContent = '0';
        document.getElementById('perspectiveV').value = 0;
        document.getElementById('perspectiveVValue').textContent = '0';
        
        // Sembunyikan semua kontrol filter
        document.querySelectorAll('.filter-controls').forEach(control => {
          control.classList.remove('active');
        });
        
        // Reset tab aktif
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        document.querySelector('.tab[data-tab="basic"]').classList.add('active');
        
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById('basic-tab').classList.add('active');
        
        activeTab = 'basic';
        activeMode = 'resize';
        
        // Terapkan perubahan
        if (originalImage) {
          applyFiltersAndResize();
        }
        
        // Tampilkan toast
        showToast('Settings reset successfully!');
      });
      
      // Event listener untuk crop tool
      document.getElementById('cropTool').addEventListener('click', function() {
        // Implementasi crop tool
        showToast('Crop tool will be implemented soon!');
      });
      
      // Event listener untuk tombol compare
      document.getElementById('compareBtn').addEventListener('click', function() {
        if (!originalImage) {
          showToast('Please upload an image first!', true);
          return;
        }
        
        isComparing = !isComparing;
        const compareBtn = document.getElementById('compareBtn');
        
        if (isComparing) {
          compareBtn.classList.add('active');
          compareBtn.title = 'Stop Compare';
          
          // Mulai bergantian antara gambar asli dan hasil edit
          let showOriginal = true;
          compareInterval = setInterval(() => {
            const preview = document.getElementById('preview');
            if (showOriginal) {
              // Tampilkan gambar asli
              preview.src = originalImage.src;
            } else {
              // Tampilkan hasil edit
              const canvas = document.getElementById('canvas');
              const quality = document.getElementById('qualityRange').value / 100;
              preview.src = canvas.toDataURL('image/jpeg', quality);
            }
            showOriginal = !showOriginal;
          }, 500);
        } else {
          compareBtn.classList.remove('active');
          compareBtn.title = 'Compare Original vs Edited';

          // Hentikan interval
          if (compareInterval) {
            clearInterval(compareInterval);
            compareInterval = null;
          }
          
          // Tampilkan hasil edit
          const canvas = document.getElementById('canvas');
          const quality = document.getElementById('qualityRange').value / 100;
          document.getElementById('preview').src = canvas.toDataURL('image/jpeg', quality);
        }
      });
      
      // Fungsi untuk menerapkan filter dan resize
      function applyFiltersAndResize() {
        if (!originalImage) return;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Dapatkan nilai resolusi
        const sizePercent = document.getElementById('sizeRange').value / 100;
        
        // Hitung ukuran baru
        const newWidth = Math.round(originalImage.width * sizePercent);
        const newHeight = Math.round(originalImage.height * sizePercent);
        
        // Set ukuran canvas
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        // Gambar gambar asli ke canvas dengan ukuran baru
        ctx.drawImage(originalImage, 0, 0, newWidth, newHeight);
        
        // Terapkan filter berdasarkan tab aktif
        if (activeTab === 'basic') {
          applyBasicFilter(ctx, activeMode, newWidth, newHeight);
        } else if (activeTab === 'artistic') {
          applyArtisticFilter(ctx, document.getElementById('artisticMode').value, newWidth, newHeight);
        } else if (activeTab === 'distortion') {
          applyDistortionFilter(ctx, document.getElementById('distortionMode').value, newWidth, newHeight);
        } else if (activeTab === 'color') {
          applyColorFilter(ctx, document.getElementById('colorMode').value, newWidth, newHeight);
        } else if (activeTab === 'cyberfunk') {
          applyCyberfunkFilter(ctx, document.getElementById('cyberfunkMode').value, newWidth, newHeight);
        }
        
        // Terapkan adjustments
        applyAdjustments(ctx, newWidth, newHeight);
        
        // Terapkan frame
        applyFrame(ctx, newWidth, newHeight);
        
        // Terapkan text
        applyText(ctx, newWidth, newHeight);
        
        // Terapkan sticker
        applySticker(ctx, newWidth, newHeight);
        
        // Terapkan advanced effects
        applyAdvancedEffects(ctx, newWidth, newHeight);
        
        // Update preview dengan canvas
        const quality = document.getElementById('qualityRange').value / 100;
        document.getElementById('preview').src = canvas.toDataURL('image/jpeg', quality);
        
        // Update informasi output
        updateOutputInfo(newWidth, newHeight);
      }
      
      // Fungsi untuk menerapkan filter dasar
      function applyBasicFilter(ctx, mode, width, height) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        switch(mode) {
          case 'resize':
            // Tidak ada filter khusus untuk resize biasa
            break;
            
          case 'noise':
            // Noise Glitch
            const noiseAmount = document.getElementById('noiseAmount') ? 
              parseInt(document.getElementById('noiseAmount').value) : 40;
            
            for (let i = 0; i < data.length; i += 4) {
              if (Math.random() * 100 < noiseAmount) {
                const offset = Math.floor(Math.random() * 20) - 10;
                data[i] = Math.min(255, Math.max(0, data[i] + offset));     // R
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + offset)); // G
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + offset)); // B
              }
            }
            break;
            
          case 'rgb':
            // RGB Shift
            const rgbShiftAmount = document.getElementById('rgbShiftAmount') ? 
              parseInt(document.getElementById('rgbShiftAmount').value) : 15;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.putImageData(imageData, 0, 0);
            
            // Hapus canvas
            ctx.clearRect(0, 0, width, height);
            
            // Gambar channel merah dengan offset
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(tempCanvas, rgbShiftAmount, 0, width, height);
            
            // Gambar channel hijau dengan offset berbeda
            ctx.globalCompositeOperation = 'multiply';
            ctx.drawImage(tempCanvas, -rgbShiftAmount, 0, width, height);
            
            // Gambar channel biru dengan offset berbeda
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(tempCanvas, 0, rgbShiftAmount, width, height);
            
            // Kembali ke mode normal
            ctx.globalCompositeOperation = 'source-over';
            return; // Karena kita sudah menggambar langsung ke ctx
            
          case 'vhs':
            // VHS Tracking
            const vhsDistortion = document.getElementById('vhsDistortion') ? 
              parseInt(document.getElementById('vhsDistortion').value) : 10;
            
            for (let y = 0; y < height; y++) {
              if (Math.random() * 100 < vhsDistortion) {
                const offset = Math.floor(Math.random() * 10) - 5;
                const lineData = ctx.getImageData(0, y, width, 1);
                ctx.putImageData(lineData, offset, y);
              }
            }
            break;
            
          case 'invert':
            // Invert Colors
            for (let i = 0; i < data.length; i += 4) {
              data[i] = 255 - data[i];     // R
              data[i + 1] = 255 - data[i + 1]; // G
              data[i + 2] = 255 - data[i + 2]; // B
            }
            break;
            
          case 'ghost':
            // Ghost Echo
            const ghostCount = document.getElementById('ghostCount') ? 
              parseInt(document.getElementById('ghostCount').value) : 2;
            const ghostOpacity = document.getElementById('ghostOpacity') ? 
              parseInt(document.getElementById('ghostOpacity').value) / 100 : 0.25;
            
            const ghostCanvas = document.createElement('canvas');
            const ghostCtx = ghostCanvas.getContext('2d');
            ghostCanvas.width = width;
            ghostCanvas.height = height;
            ghostCtx.putImageData(imageData, 0, 0);
            
            ctx.globalAlpha = ghostOpacity;
            for (let i = 1; i <= ghostCount; i++) {
              ctx.drawImage(ghostCanvas, i * 5, i * 5, width, height);
            }
            ctx.globalAlpha = 1.0;
            break;
            
          case 'pixelate':
            // Pixelate
            const pixelSize = document.getElementById('pixelSize') ? 
              parseInt(document.getElementById('pixelSize').value) : 8;
            
            for (let y = 0; y < height; y += pixelSize) {
              for (let x = 0; x < width; x += pixelSize) {
                const pixelData = ctx.getImageData(x, y, 1, 1).data;
                ctx.fillStyle = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
                ctx.fillRect(x, y, pixelSize, pixelSize);
              }
            }
            break;
            
          case 'sepia':
            // Sepia Rusak
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));     // R
              data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // G
              data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // B
            }
            break;
            
          case 'oversat':
            // Over Saturation
            const saturationAmount = document.getElementById('saturationAmount') ? 
              parseFloat(document.getElementById('saturationAmount').value) : 1.6;
            
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i] / 255;
              const g = data[i + 1] / 255;
              const b = data[i + 2] / 255;
              
              const max = Math.max(r, g, b);
              const min = Math.min(r, g, b);
              let h, s, l = (max + min) / 2;
              
              if (max === min) {
                h = s = 0;
              } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                  case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                  case g: h = (b - r) / d + 2; break;
                  case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
              }

              // Tingkatkan saturasi
              s = Math.min(1, s * saturationAmount);
              
              // Konversi kembali ke RGB
              let r2, g2, b2;
              
              if (s === 0) {
                r2 = g2 = b2 = l;
              } else {
                const hue2rgb = (p, q, t) => {
                  if (t < 0) t += 1;
                  if (t > 1) t -= 1;
                  if (t < 1/6) return p + (q - p) * 6 * t;
                  if (t < 1/2) return q;
                  if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                  return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
              }
              
              data[i] = Math.round(r2 * 255);
              data[i + 1] = Math.round(g2 * 255);
              data[i + 2] = Math.round(b2 * 255);
            }
            break;
            
          case 'graynoise':
            // Grayscale Noise
            const graynoiseAmount = document.getElementById('graynoiseAmount') ? 
              parseInt(document.getElementById('graynoiseAmount').value) : 50;
            
            for (let i = 0; i < data.length; i += 4) {
              // Konversi ke grayscale
              const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
              
              // Tambahkan noise
              const noise = (Math.random() - 0.5) * graynoiseAmount;
              const noisyGray = Math.min(255, Math.max(0, gray + noise));
              
              data[i] = noisyGray;     // R
              data[i + 1] = noisyGray; // G
              data[i + 2] = noisyGray; // B
            }
            break;
            
          case 'scanline':
            // Scanline CRT
            const scanlineSize = document.getElementById('scanlineSize') ? 
              parseInt(document.getElementById('scanlineSize').value) : 4;
            const scanlineOpacity = document.getElementById('scanlineOpacity') ? 
              parseInt(document.getElementById('scanlineOpacity').value) / 100 : 0.3;
            
            for (let y = 0; y < height; y += scanlineSize * 2) {
              ctx.fillStyle = `rgba(0, 0, 0, ${scanlineOpacity})`;
              ctx.fillRect(0, y, width, scanlineSize);
            }
            break;
            
          case 'burned':
            // Burned Contrast
            const burnedAmount = document.getElementById('burnedAmount') ? 
              parseFloat(document.getElementById('burnedAmount').value) : 1.8;
            
            for (let i = 0; i < data.length; i += 4) {
              // Tingkatkan kontras
              const factor = (259 * (burnedAmount + 255)) / (255 * (259 - burnedAmount));
              
              data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));     // R
              data[i + 1] = Math.min(255, Math.max(0, factor * (data[i + 1] - 128) + 128)); // G
              data[i + 2] = Math.min(255, Math.max(0, factor * (data[i + 2] - 128) + 128)); // B
            }
            break;
            
          case 'swap':
            // Random Color Swap
            for (let i = 0; i < data.length; i += 4) {
              if (Math.random() < 0.1) {
                // Tukar nilai RGB secara acak
                const temp = data[i];
                data[i] = data[i + 1];
                data[i + 1] = data[i + 2];
                data[i + 2] = temp;
              }
            }
            break;
        }
        
        // Jika bukan filter khusus yang sudah ditangani di atas, terapkan perubahan ke imageData
        if (mode !== 'rgb' && mode !== 'vhs' && mode !== 'ghost' && mode !== 'pixelate' && mode !== 'scanline') {
          ctx.putImageData(imageData, 0, 0);
        }
      }
      
      // Fungsi untuk menerapkan filter artistic
      function applyArtisticFilter(ctx, mode, width, height) {
        if (mode === 'none') return;
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        switch(mode) {
          case 'watercolor':
            // Watercolor Effect
            const watercolorBrush = document.getElementById('watercolorBrush') ? 
              parseInt(document.getElementById('watercolorBrush').value) : 8;
            const watercolorIntensity = document.getElementById('watercolorIntensity') ? 
              parseInt(document.getElementById('watercolorIntensity').value) / 100 : 0.7;
            
            // Buat efek watercolor dengan blur dan noise
            ctx.filter = `blur(${watercolorBrush / 2}px)`;
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.filter = 'none';
            
            // Tambahkan noise untuk tekstur
            const watercolorData = ctx.getImageData(0, 0, width, height);
            const watercolorPixels = watercolorData.data;
            
            for (let i = 0; i < watercolorPixels.length; i += 4) {
              if (Math.random() < watercolorIntensity * 0.1) {
                const noise = (Math.random() - 0.5) * 50;
                watercolorPixels[i] = Math.min(255, Math.max(0, watercolorPixels[i] + noise));
                watercolorPixels[i + 1] = Math.min(255, Math.max(0, watercolorPixels[i + 1] + noise));
                watercolorPixels[i + 2] = Math.min(255, Math.max(0, watercolorPixels[i + 2] + noise));
              }
            }
            
            ctx.putImageData(watercolorData, 0, 0);
            break;
            
          case 'oilpainting':
            // Oil Painting Effect
            const oilBrush = document.getElementById('oilBrush') ? 
              parseInt(document.getElementById('oilBrush').value) : 5;
            const oilIntensity = document.getElementById('oilIntensity') ? 
              parseInt(document.getElementById('oilIntensity').value) / 100 : 0.6;
            
            // Buat efek oil painting dengan median filter
            const oilData = ctx.createImageData(width, height);
            const oilPixels = oilData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const r = [], g = [], b = [];
                
                // Kumpulkan piksel di sekitar
                for (let dy = -oilBrush; dy <= oilBrush; dy++) {
                  for (let dx = -oilBrush; dx <= oilBrush; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                      const idx = (ny * width + nx) * 4;
                      r.push(data[idx]);
                      g.push(data[idx + 1]);
                      b.push(data[idx + 2]);
                    }
                  }
                }
                
                // Hitung median
                r.sort((a, b) => a - b);
                g.sort((a, b) => a - b);
                b.sort((a, b) => a - b);
                
                const medianIdx = Math.floor(r.length / 2);
                
                const idx = (y * width + x) * 4;
                oilPixels[idx] = r[medianIdx];
                oilPixels[idx + 1] = g[medianIdx];
                oilPixels[idx + 2] = b[medianIdx];
                oilPixels[idx + 3] = 255;
              }
            }
            
            ctx.putImageData(oilData, 0, 0);
            break;
            
          case 'sketch':
            // Pencil Sketch Effect
            const sketchPencil = document.getElementById('sketchPencil') ? 
              parseFloat(document.getElementById('sketchPencil').value) : 1;
            const sketchDarkness = document.getElementById('sketchDarkness') ? 
              parseInt(document.getElementById('sketchDarkness').value) / 100 : 0.7;
            
            // Konversi ke grayscale
            const grayData = ctx.createImageData(width, height);
            const grayPixels = grayData.data;
            
            for (let i = 0; i < data.length; i += 4) {
              const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
              grayPixels[i] = gray;
              grayPixels[i + 1] = gray;
              grayPixels[i + 2] = gray;
              grayPixels[i + 3] = 255;
            }
            
            ctx.putImageData(grayData, 0, 0);
            
            // Terapkan edge detection
            const sketchData = ctx.getImageData(0, 0, width, height);
            const sketchPixels = sketchData.data;
            
            for (let y = 1; y < height - 1; y++) {
              for (let x = 1; x < width - 1; x++) {
                const idx = (y * width + x) * 4;
                
                // Hitung gradien
                const gx = 
                  -grayPixels[((y - 1) * width + (x - 1)) * 4] +
                  grayPixels[((y - 1) * width + (x + 1)) * 4] +
                  -2 * grayPixels[(y * width + (x - 1)) * 4] +
                  2 * grayPixels[(y * width + (x + 1)) * 4] +
                  -grayPixels[((y + 1) * width + (x - 1)) * 4] +
                  grayPixels[((y + 1) * width + (x + 1)) * 4];
                
                const gy = 
                  -grayPixels[((y - 1) * width + (x - 1)) * 4] +
                  -2 * grayPixels[((y - 1) * width + x) * 4] +
                  -grayPixels[((y - 1) * width + (x + 1)) * 4] +
                  grayPixels[((y + 1) * width + (x - 1)) * 4] +
                  2 * grayPixels[((y + 1) * width + x) * 4] +
                  grayPixels[((y + 1) * width + (x + 1)) * 4];
                
                const magnitude = Math.sqrt(gx * gx + gy * gy);
                const edge = Math.min(255, magnitude * sketchPencil);

                // Invert untuk membuat sketsa
                const sketchValue = 255 - (edge * sketchDarkness);
                
                sketchPixels[idx] = sketchValue;
                sketchPixels[idx + 1] = sketchValue;
                sketchPixels[idx + 2] = sketchValue;
              }
            }
            
            ctx.putImageData(sketchData, 0, 0);
            break;
            
          case 'pointillism':
            // Pointillism Effect
            const pointSize = 3;
            
            ctx.clearRect(0, 0, width, height);
            
            for (let y = 0; y < height; y += pointSize * 2) {
              for (let x = 0; x < width; x += pointSize * 2) {
                const idx = (y * width + x) * 4;
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                
                // Gambar titik dengan posisi acak
                const offsetX = (Math.random() - 0.5) * pointSize * 2;
                const offsetY = (Math.random() - 0.5) * pointSize * 2;
                
                ctx.beginPath();
                ctx.arc(x + offsetX, y + offsetY, pointSize, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            break;
            
          case 'halftone':
            // Halftone Dots Effect
            const dotSize = 4;
            
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, width, height);
            
            for (let y = 0; y < height; y += dotSize * 2) {
              for (let x = 0; x < width; x += dotSize * 2) {
                const idx = (y * width + x) * 4;
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];
                
                // Hitung kecerahan
                const brightness = (r + g + b) / 3;
                const radius = (brightness / 255) * dotSize;
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                
                ctx.beginPath();
                ctx.arc(x + dotSize, y + dotSize, radius, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            break;
            
          case 'crosshatch':
            // Cross Hatch Effect
            const hatchSpacing = 4;
            
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);
            
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            
            // Gambar garis diagonal
            for (let y = 0; y < height; y += hatchSpacing) {
              for (let x = 0; x < width; x += hatchSpacing) {
                const idx = (y * width + x) * 4;
                const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                
                if (brightness < 128) {
                  ctx.beginPath();
                  ctx.moveTo(x, y);
                  ctx.lineTo(x + hatchSpacing, y + hatchSpacing);
                  ctx.stroke();
                  
                  ctx.beginPath();
                  ctx.moveTo(x + hatchSpacing, y);
                  ctx.lineTo(x, y + hatchSpacing);
                  ctx.stroke();
                }
              }
            }
            break;
            
          case 'mosaic':
            // Mosaic Tiles Effect
            const tileSize = 10;
            
            for (let y = 0; y < height; y += tileSize) {
              for (let x = 0; x < width; x += tileSize) {
                // Hitung rata-rata warna di tile
                let r = 0, g = 0, b = 0, count = 0;
                
                for (let dy = 0; dy < tileSize && y + dy < height; dy++) {
                  for (let dx = 0; dx < tileSize && x + dx < width; dx++) {
                    const idx = ((y + dy) * width + (x + dx)) * 4;
                    r += data[idx];
                    g += data[idx + 1];
                    b += data[idx + 2];
                    count++;
                  }
                }
                
                r = Math.floor(r / count);
                g = Math.floor(g / count);
                b = Math.floor(b / count);
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(x, y, tileSize, tileSize);
                
                // Tambahkan garis tile
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, tileSize, tileSize);
              }
            }
            break;
            
          case 'stainedglass':
            // Stained Glass Effect
            const glassSize = 15;
            
            for (let y = 0; y < height; y += glassSize) {
              for (let x = 0; x < width; x += glassSize) {
                // Ambil warna dari titik acak di dalam segmen
                const rx = x + Math.floor(Math.random() * glassSize);
                const ry = y + Math.floor(Math.random() * glassSize);
                
                if (rx < width && ry < height) {
                  const idx = (ry * width + rx) * 4;
                  const r = data[idx];
                  const g = data[idx + 1];
                  const b = data[idx + 2];
                  
                  ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                  
                  // Gambar segmen dengan bentuk acak
                  ctx.beginPath();
                  ctx.moveTo(x, y);
                  ctx.lineTo(x + glassSize, y);
                  ctx.lineTo(x + glassSize / 2, y + glassSize);
                  ctx.closePath();
                  ctx.fill();
                  
                  // Tambahkan garis lead
                  ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                }
              }
            }
            break;
        }
      }
      
      // Fungsi untuk menerapkan filter distortion
      function applyDistortionFilter(ctx, mode, width, height) {
        if (mode === 'none') return;
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        switch(mode) {
          case 'ripple':
            // Ripple Effect
            const rippleSize = document.getElementById('rippleSize') ? 
              parseInt(document.getElementById('rippleSize').value) : 20;
            const rippleFreq = document.getElementById('rippleFreq') ? 
              parseFloat(document.getElementById('rippleFreq').value) : 0.05;
            
            const rippleData = ctx.createImageData(width, height);
            const ripplePixels = rippleData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                // Hitung offset berdasarkan jarak dari pusat
                const centerX = width / 2;
                const centerY = height / 2;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                
                // Hitung ripple
                const ripple = Math.sin(distance * rippleFreq) * rippleSize;
                
                // Hitung koordinat sumber
                const angle = Math.atan2(y - centerY, x - centerX);
                const sourceX = Math.floor(centerX + (distance + ripple) * Math.cos(angle));
                const sourceY = Math.floor(centerY + (distance + ripple) * Math.sin(angle));
                
                // Salin piksel
                if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                  const sourceIdx = (sourceY * width + sourceX) * 4;
                  const targetIdx = (y * width + x) * 4;
                  
                  ripplePixels[targetIdx] = data[sourceIdx];
                  ripplePixels[targetIdx + 1] = data[sourceIdx + 1];
                  ripplePixels[targetIdx + 2] = data[sourceIdx + 2];
                  ripplePixels[targetIdx + 3] = data[sourceIdx + 3];
                }
              }
            }

            ctx.putImageData(rippleData, 0, 0);
            break;
            
          case 'bulge':
            // Bulge Effect
            const bulgeStrength = 0.5;
            const bulgeRadius = Math.min(width, height) / 2;
            
            const bulgeData = ctx.createImageData(width, height);
            const bulgePixels = bulgeData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const centerX = width / 2;
                const centerY = height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < bulgeRadius) {
                  // Hitung faktor bulge
                  const factor = 1 + bulgeStrength * (1 - distance / bulgeRadius);
                  
                  // Hitung koordinat sumber
                  const sourceX = Math.floor(centerX + dx / factor);
                  const sourceY = Math.floor(centerY + dy / factor);
                  
                  // Salin piksel
                  if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIdx = (sourceY * width + sourceX) * 4;
                    const targetIdx = (y * width + x) * 4;
                    
                    bulgePixels[targetIdx] = data[sourceIdx];
                    bulgePixels[targetIdx + 1] = data[sourceIdx + 1];
                    bulgePixels[targetIdx + 2] = data[sourceIdx + 2];
                    bulgePixels[targetIdx + 3] = data[sourceIdx + 3];
                  }
                } else {
                  // Salin piksel asli
                  const idx = (y * width + x) * 4;
                  bulgePixels[idx] = data[idx];
                  bulgePixels[idx + 1] = data[idx + 1];
                  bulgePixels[idx + 2] = data[idx + 2];
                  bulgePixels[idx + 3] = data[idx + 3];
                }
              }
            }
            
            ctx.putImageData(bulgeData, 0, 0);
            break;
            
          case 'pinch':
            // Pinch Effect
            const pinchStrength = 0.5;
            const pinchRadius = Math.min(width, height) / 2;
            
            const pinchData = ctx.createImageData(width, height);
            const pinchPixels = pinchData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const centerX = width / 2;
                const centerY = height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < pinchRadius) {
                  // Hitung faktor pinch
                  const factor = 1 - pinchStrength * (1 - distance / pinchRadius);
                  
                  // Hitung koordinat sumber
                  const sourceX = Math.floor(centerX + dx * factor);
                  const sourceY = Math.floor(centerY + dy * factor);
                  
                  // Salin piksel
                  if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIdx = (sourceY * width + sourceX) * 4;
                    const targetIdx = (y * width + x) * 4;
                    
                    pinchPixels[targetIdx] = data[sourceIdx];
                    pinchPixels[targetIdx + 1] = data[sourceIdx + 1];
                    pinchPixels[targetIdx + 2] = data[sourceIdx + 2];
                    pinchPixels[targetIdx + 3] = data[sourceIdx + 3];
                  }
                } else {
                  // Salin piksel asli
                  const idx = (y * width + x) * 4;
                  pinchPixels[idx] = data[idx];
                  pinchPixels[idx + 1] = data[idx + 1];
                  pinchPixels[idx + 2] = data[idx + 2];
                  pinchPixels[idx + 3] = data[idx + 3];
                }
              }
            }
            
            ctx.putImageData(pinchData, 0, 0);
            break;
            
          case 'swirl':
            // Swirl Effect
            const swirlStrength = 5;
            const swirlRadius = Math.min(width, height) / 2;
            
            const swirlData = ctx.createImageData(width, height);
            const swirlPixels = swirlData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const centerX = width / 2;
                const centerY = height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < swirlRadius) {
                  // Hitung sudut
                  let angle = Math.atan2(dy, dx);
                  
                  // Tambahkan swirl
                  angle += swirlStrength * (1 - distance / swirlRadius);

                  // Hitung koordinat sumber
                  const sourceX = Math.floor(centerX + distance * Math.cos(angle));
                  const sourceY = Math.floor(centerY + distance * Math.sin(angle));
                  
                  // Salin piksel
                  if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIdx = (sourceY * width + sourceX) * 4;
                    const targetIdx = (y * width + x) * 4;
                    
                    swirlPixels[targetIdx] = data[sourceIdx];
                    swirlPixels[targetIdx + 1] = data[sourceIdx + 1];
                    swirlPixels[targetIdx + 2] = data[sourceIdx + 2];
                    swirlPixels[targetIdx + 3] = data[sourceIdx + 3];
                  }
                } else {
                  // Salin piksel asli
                  const idx = (y * width + x) * 4;
                  swirlPixels[idx] = data[idx];
                  swirlPixels[idx + 1] = data[idx + 1];
                  swirlPixels[idx + 2] = data[idx + 2];
                  swirlPixels[idx + 3] = data[idx + 3];
                }
              }
            }
            
            ctx.putImageData(swirlData, 0, 0);
            break;
            
          case 'fisheye':
            // Fisheye Lens Effect
            const fisheyeStrength = 0.5;
            const fisheyeRadius = Math.min(width, height) / 2;
            
            const fisheyeData = ctx.createImageData(width, height);
            const fisheyePixels = fisheyeData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const centerX = width / 2;
                const centerY = height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < fisheyeRadius) {
                  // Hitung faktor fisheye
                  const normalizedDistance = distance / fisheyeRadius;
                  const factor = Math.pow(normalizedDistance, fisheyeStrength);
                  
                  // Hitung koordinat sumber
                  const sourceX = Math.floor(centerX + dx * factor);
                  const sourceY = Math.floor(centerY + dy * factor);
                  
                  // Salin piksel
                  if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIdx = (sourceY * width + sourceX) * 4;
                    const targetIdx = (y * width + x) * 4;
                    
                    fisheyePixels[targetIdx] = data[sourceIdx];
                    fisheyePixels[targetIdx + 1] = data[sourceIdx + 1];
                    fisheyePixels[targetIdx + 2] = data[sourceIdx + 2];
                    fisheyePixels[targetIdx + 3] = data[sourceIdx + 3];
                  }
                } else {
                  // Salin piksel asli
                  const idx = (y * width + x) * 4;
                  fisheyePixels[idx] = data[idx];
                  fisheyePixels[idx + 1] = data[idx + 1];
                  fisheyePixels[idx + 2] = data[idx + 2];
                  fisheyePixels[idx + 3] = data[idx + 3];
                }
              }
            }
            
            ctx.putImageData(fisheyeData, 0, 0);
            break;
            
          case 'kaleidoscope':
            // Kaleidoscope Effect
            const segments = 8;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2;
            
            const kaleidoscopeData = ctx.createImageData(width, height);
            const kaleidoscopePixels = kaleidoscopeData.data;
            
            // Buat segmen pertama
            const segmentAngle = (Math.PI * 2) / segments;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < radius) {
                  // Hitung sudut
                  let angle = Math.atan2(dy, dx);
                  
                  // Normalisasi sudut ke segmen pertama
                  angle = ((angle % segmentAngle) + segmentAngle) % segmentAngle;
                  
                  // Hitung koordinat sumber di segmen pertama
                  const sourceX = Math.floor(centerX + distance * Math.cos(angle));
                  const sourceY = Math.floor(centerY + distance * Math.sin(angle));
                  
                  // Salin piksel
                  if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIdx = (sourceY * width + sourceX) * 4;
                    const targetIdx = (y * width + x) * 4;
                    
                    kaleidoscopePixels[targetIdx] = data[sourceIdx];
                    kaleidoscopePixels[targetIdx + 1] = data[sourceIdx + 1];
                    kaleidoscopePixels[targetIdx + 2] = data[sourceIdx + 2];
                    kaleidoscopePixels[targetIdx + 3] = data[sourceIdx + 3];
                  }
                }
              }
            }
            
            ctx.putImageData(kaleidoscopeData, 0, 0);
            break;
            
          case 'mirror':
            // Mirror Effect
            const mirrorData = ctx.createImageData(width, height);
            const mirrorPixels = mirrorData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                // Hitung koordinat sumber (mirror horizontal)
                const sourceX = width - x - 1;
                
                // Salin piksel
                const sourceIdx = (y * width + sourceX) * 4;
                const targetIdx = (y * width + x) * 4;
                
                mirrorPixels[targetIdx] = data[sourceIdx];
                mirrorPixels[targetIdx + 1] = data[sourceIdx + 1];
                mirrorPixels[targetIdx + 2] = data[sourceIdx + 2];
                mirrorPixels[targetIdx + 3] = data[sourceIdx + 3];
              }
            }
            
            ctx.putImageData(mirrorData, 0, 0);
            break;
            
          case 'tunnel':
            // Tunnel Vision Effect
            const tunnelStrength = 0.8;
            const tunnelRadius = Math.min(width, height) / 2;
            
            const tunnelData = ctx.createImageData(width, height);
            const tunnelPixels = tunnelData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const centerX = width / 2;
                const centerY = height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < tunnelRadius) {
                  // Hitung faktor tunnel
                  const normalizedDistance = distance / tunnelRadius;
                  const factor = Math.pow(normalizedDistance, tunnelStrength);
                  
                  // Hitung koordinat sumber
                  const sourceX = Math.floor(centerX + dx * factor);
                  const sourceY = Math.floor(centerY + dy * factor);
                  
                  // Salin piksel
                  if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIdx = (sourceY * width + sourceX) * 4;
                    const targetIdx = (y * width + x) * 4;
                    
                    tunnelPixels[targetIdx] = data[sourceIdx];
                    tunnelPixels[targetIdx + 1] = data[sourceIdx + 1];
                    tunnelPixels[targetIdx + 2] = data[sourceIdx + 2];
                    tunnelPixels[targetIdx + 3] = data[sourceIdx + 3];
                  }
                } else {
                  // Hitam di luar tunnel
                  const idx = (y * width + x) * 4;
                  tunnelPixels[idx] = 0;
                  tunnelPixels[idx + 1] = 0;
                  tunnelPixels[idx + 2] = 0;
                  tunnelPixels[idx + 3] = 255;
                }
              }
            }

            ctx.putImageData(tunnelData, 0, 0);
            break;
        }
      }
      
      // Fungsi untuk menerapkan filter color
      function applyColorFilter(ctx, mode, width, height) {
        if (mode === 'none') return;
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        switch(mode) {
          case 'duotone':
            // Duotone Effect
            const duotoneDark = document.getElementById('duotoneDark') ? 
              hexToRgb(document.getElementById('duotoneDark').value) : { r: 0, g: 0, b: 255 };
            const duotoneLight = document.getElementById('duotoneLight') ? 
              hexToRgb(document.getElementById('duotoneLight').value) : { r: 255, g: 255, b: 0 };
            
            for (let i = 0; i < data.length; i += 4) {
              // Hitung kecerahan
              const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3 / 255;
              
              // Interpolasi antara warna gelap dan terang
              data[i] = duotoneDark.r + (duotoneLight.r - duotoneDark.r) * brightness;
              data[i + 1] = duotoneDark.g + (duotoneLight.g - duotoneDark.g) * brightness;
              data[i + 2] = duotoneDark.b + (duotoneLight.b - duotoneDark.b) * brightness;
            }
            break;
            
          case 'posterize':
            // Posterize Effect
            const levels = 4;
            
            for (let i = 0; i < data.length; i += 4) {
              data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);
              data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels);
              data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels);
            }
            break;
            
          case 'solarize':
            // Solarize Effect
            for (let i = 0; i < data.length; i += 4) {
              data[i] = data[i] > 128 ? 255 - data[i] : data[i];
              data[i + 1] = data[i + 1] > 128 ? 255 - data[i + 1] : data[i + 1];
              data[i + 2] = data[i + 2] > 128 ? 255 - data[i + 2] : data[i + 2];
            }
            break;
            
          case 'edgeglow':
            // Edge Glow Effect
            const edgeData = ctx.createImageData(width, height);
            const edgePixels = edgeData.data;
            
            // Deteksi tepi
            for (let y = 1; y < height - 1; y++) {
              for (let x = 1; x < width - 1; x++) {
                const idx = (y * width + x) * 4;
                
                // Hitung gradien
                const gx = 
                  -data[((y - 1) * width + (x - 1)) * 4] +
                  data[((y - 1) * width + (x + 1)) * 4] +
                  -2 * data[(y * width + (x - 1)) * 4] +
                  2 * data[(y * width + (x + 1)) * 4] +
                  -data[((y + 1) * width + (x - 1)) * 4] +
                  data[((y + 1) * width + (x + 1)) * 4];
                
                const gy = 
                  -data[((y - 1) * width + (x - 1)) * 4] +
                  -2 * data[((y - 1) * width + x) * 4] +
                  -data[((y - 1) * width + (x + 1)) * 4] +
                  data[((y + 1) * width + (x - 1)) * 4] +
                  2 * data[((y + 1) * width + x) * 4] +
                  data[((y + 1) * width + (x + 1)) * 4];
                
                const magnitude = Math.sqrt(gx * gx + gy * gy);
                const edge = Math.min(255, magnitude);
                
                // Buat efek glow
                const glow = Math.min(255, edge * 2);
                
                edgePixels[idx] = glow;
                edgePixels[idx + 1] = glow * 0.8;
                edgePixels[idx + 2] = glow * 0.6;
                edgePixels[idx + 3] = 255;
              }
            }
            
            ctx.putImageData(edgeData, 0, 0);
            break;
            
          case 'chromatic':
            // Chromatic Aberration Effect
            const shiftAmount = 5;
            
            const chromaticData = ctx.createImageData(width, height);
            const chromaticPixels = chromaticData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const idx = (y * width + x) * 4;
                
                // Channel merah (shift kiri)
                if (x - shiftAmount >= 0) {
                  const redIdx = (y * width + (x - shiftAmount)) * 4;
                  chromaticPixels[idx] = data[redIdx];
                } else {
                  chromaticPixels[idx] = data[idx];
                }
                
                // Channel hijau (tidak di-shift)
                chromaticPixels[idx + 1] = data[idx + 1];
                
                // Channel biru (shift kanan)
                if (x + shiftAmount < width) {
                  const blueIdx = (y * width + (x + shiftAmount)) * 4;
                  chromaticPixels[idx + 2] = data[blueIdx + 2];
                } else {
                  chromaticPixels[idx + 2] = data[idx + 2];
                }
                
                chromaticPixels[idx + 3] = data[idx + 3];
              }
            }
            
            ctx.putImageData(chromaticData, 0, 0);
            break;
            
          case 'thermal':
            // Thermal Vision Effect
            for (let i = 0; i < data.length; i += 4) {
              // Hitung kecerahan
              const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
              
              // Mapping ke warna thermal
              if (brightness < 85) {
                // Hitam ke biru
                data[i] = 0;
                data[i + 1] = 0;
                data[i + 2] = brightness * 3;
              } else if (brightness < 170) {
                // Biru ke merah
                const t = (brightness - 85) / 85;
                data[i] = t * 255;
                data[i + 1] = 0;
                data[i + 2] = (1 - t) * 255;
              } else {
                // Merah ke kuning
                const t = (brightness - 170) / 85;
                data[i] = 255;
                data[i + 1] = t * 255;
                data[i + 2] = 0;
              }
            }
            break;
            
          case 'xray':
            // X-Ray Effect
            for (let i = 0; i < data.length; i += 4) {
              // Invert dan kontras tinggi
              data[i] = Math.min(255, Math.max(0, 255 - data[i] * 1.5));
              data[i + 1] = Math.min(255, Math.max(0, 255 - data[i + 1] * 1.5));
              data[i + 2] = Math.min(255, Math.max(0, 255 - data[i + 2] * 1.5));
            }
            break;
            
          case 'infrared':
            // Infrared Effect
            for (let i = 0; i < data.length; i += 4) {
              // Tukar merah dan biru, tingkatkan kontras
              const temp = data[i];
              data[i] = Math.min(255, data[i + 2] * 1.2);
              data[i + 1] = Math.min(255, data[i + 1] * 0.8);
              data[i + 2] = Math.min(255, temp * 0.5);
            }
            break;
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      // Fungsi untuk menerapkan filter cyberfunk
      function applyCyberfunkFilter(ctx, mode, width, height) {
        if (mode === 'none') return;
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        switch(mode) {
          case 'neonglow':
            // Neon Glow Effect
            const neonColor = document.getElementById('neonColor') ? 
              hexToRgb(document.getElementById('neonColor').value) : { r: 255, g: 0, b: 255 };
            const glowIntensity = document.getElementById('glowIntensity') ? 
              parseInt(document.getElementById('glowIntensity').value) / 100 : 0.8;
            
            // Buat efek glow dengan blur
            ctx.filter = `blur(5px)`;
            ctx.globalAlpha = glowIntensity;
            ctx.fillStyle = `rgb(${neonColor.r}, ${neonColor.g}, ${neonColor.b})`;
            ctx.fillRect(0, 0, width, height);
            ctx.filter = 'none';
            ctx.globalAlpha = 1.0;
            
            // Gambar gambar asli di atas
            ctx.drawImage(ctx.canvas, 0, 0);
            break;
            
          case 'cybergrid':
            // Cyber Grid Effect
            const gridSize = document.getElementById('gridSize') ? 
              parseInt(document.getElementById('gridSize').value) : 20;
            const gridColor = document.getElementById('gridColor') ? 
              hexToRgb(document.getElementById('gridColor').value) : { r: 0, g: 255, b: 255 };
            
            // Gambar grid
            ctx.strokeStyle = `rgba(${gridColor.r}, ${gridColor.g}, ${gridColor.b}, 0.7)`;
            ctx.lineWidth = 1;
            
            for (let x = 0; x < width; x += gridSize) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, height);
              ctx.stroke();
            }
            
            for (let y = 0; y < height; y += gridSize) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(width, y);
              ctx.stroke();
            }
            break;
            
          case 'hologram':
            // Hologram Effect
            const interference = document.getElementById('interference') ? 
              parseInt(document.getElementById('interference').value) / 100 : 0.5;
            const transparency = document.getElementById('transparency') ? 
              parseInt(document.getElementById('transparency').value) / 100 : 0.7;
            
            // Buat efek hologram dengan noise dan scanlines
            const hologramData = ctx.createImageData(width, height);
            const hologramPixels = hologramData.data;
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const idx = (y * width + x) * 4;
                
                // Tambahkan noise
                const noise = (Math.random() - 0.5) * interference * 255;
                
                // Tambahkan efek scanline
                const scanline = (y % 4 < 2) ? 1 : 0.7;
                
                hologramPixels[idx] = Math.min(255, Math.max(0, data[idx] + noise)) * scanline;
                hologramPixels[idx + 1] = Math.min(255, Math.max(0, data[idx + 1] + noise)) * scanline;
                hologramPixels[idx + 2] = Math.min(255, Math.max(0, data[idx + 2] + noise)) * scanline;
                hologramPixels[idx + 3] = data[idx + 3] * transparency;
              }
            }
            
            ctx.putImageData(hologramData, 0, 0);
            break;
            
          case 'digitalglitch':
            // Digital Glitch Effect
            const glitchAmount = document.getElementById('glitchAmount') ? 
              parseInt(document.getElementById('glitchAmount').value) / 100 : 0.3;
            const colorShift = document.getElementById('colorShift') ? 
              parseInt(document.getElementById('colorShift').value) : 15;
            
            const glitchData = ctx.createImageData(width, height);
            const glitchPixels = glitchData.data;
            
            for (let y = 0; y < height; y++) {
              // Acak apakah baris ini akan di-glitch
              if (Math.random() < glitchAmount) {
                // Pilih jenis glitch secara acak
                const glitchType = Math.floor(Math.random() * 3);
                
                if (glitchType === 0) {
                  // Shift channel warna
                  for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Channel merah (shift kiri)
                    if (x - colorShift >= 0) {
                      const redIdx = (y * width + (x - colorShift)) * 4;
                      glitchPixels[idx] = data[redIdx];
                    } else {
                      glitchPixels[idx] = data[idx];
                    }
                    
                    // Channel hijau (tidak di-shift)
                    glitchPixels[idx + 1] = data[idx + 1];
                    
                    // Channel biru (shift kanan)
                    if (x + colorShift < width) {
                      const blueIdx = (y * width + (x + colorShift)) * 4;
                      glitchPixels[idx + 2] = data[blueIdx + 2];
                    } else {
                      glitchPixels[idx + 2] = data[idx + 2];
                    }
                    
                    glitchPixels[idx + 3] = data[idx + 3];
                  }
                } else if (glitchType === 1) {
                  // Duplikasi baris
                  const sourceY = Math.floor(Math.random() * height);
                  const sourceRowStart = sourceY * width * 4;
                  const targetRowStart = y * width * 4;
                  
                  for (let x = 0; x < width * 4; x++) {
                    glitchPixels[targetRowStart + x] = data[sourceRowStart + x];
                  }
                } else {
                  // Noise
                  for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    glitchPixels[idx] = Math.random() * 255;
                    glitchPixels[idx + 1] = Math.random() * 255;
                    glitchPixels[idx + 2] = Math.random() * 255;
                    glitchPixels[idx + 3] = 255;
                  }
                }
              } else {
                // Salin baris asli
                for (let x = 0; x < width; x++) {
                  const idx = (y * width + x) * 4;
                  glitchPixels[idx] = data[idx];
                  glitchPixels[idx + 1] = data[idx + 1];
                  glitchPixels[idx + 2] = data[idx + 2];
                  glitchPixels[idx + 3] = data[idx + 3];
                }
              }
            }
            
            ctx.putImageData(glitchData, 0, 0);
            break;
            
          case 'synthwave':
            // Synthwave Effect
            const sunColor = document.getElementById('sunColor') ? 
              hexToRgb(document.getElementById('sunColor').value) : { r: 255, g: 0, b: 170 };
            const horizonHeight = document.getElementById('horizonHeight') ? 
              parseInt(document.getElementById('horizonHeight').value) / 100 : 0.6;
            
            // Buat gradien synthwave
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#1a0033');
            gradient.addColorStop(horizonHeight, '#330066');
            gradient.addColorStop(1, '#ff0066');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Gambar matahari
            const sunY = height * horizonHeight;
            const sunRadius = height * 0.1;
            
            const sunGradient = ctx.createRadialGradient(
              width / 2, sunY, 0,
              width / 2, sunY, sunRadius
            );
            sunGradient.addColorStop(0, `rgba(${sunColor.r}, ${sunColor.g}, ${sunColor.b}, 1)`);
            sunGradient.addColorStop(1, `rgba(${sunColor.r}, ${sunColor.g}, ${sunColor.b}, 0)`);
            
            ctx.fillStyle = sunGradient;
            ctx.fillRect(0, sunY - sunRadius, width, sunRadius * 2);
            
            // Gambar grid
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x < width; x += 20) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x + (height - sunY) * 0.5, height);
              ctx.stroke();
            }
            
            // Gambar gambar asli dengan blending
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.7;
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            break;
            
          case 'cyberpunk':
            // Cyberpunk Effect
            const accentColor = document.getElementById('accentColor') ? 
              hexToRgb(document.getElementById('accentColor').value) : { r: 0, g: 255, b: 0 };
            const darkness = document.getElementById('darkness') ? 
              parseInt(document.getElementById('darkness').value) / 100 : 0.4;
            
            // Terapkan darkness
            for (let i = 0; i < data.length; i += 4) {
              data[i] *= (1 - darkness);
              data[i + 1] *= (1 - darkness);
              data[i + 2] *= (1 - darkness);
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Tambahkan aksen cyberpunk
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.5;
            
            // Gambar garis vertikal
            ctx.strokeStyle = `rgba(${accentColor.r}, ${accentColor.g}, ${accentColor.b}, 0.7)`;
            ctx.lineWidth = 2;
            
            for (let x = 0; x < width; x += 30) {
              if (Math.random() > 0.7) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
              }
            }
            
            // Gambar teks cyberpunk
            ctx.font = '20px monospace';
            ctx.fillStyle = `rgba(${accentColor.r}, ${accentColor.g}, ${accentColor.b}, 0.8)`;
            
            for (let y = 20; y < height; y += 30) {
              for (let x = 0; x < width; x += 100) {
                if (Math.random() > 0.8) {
                  const text = Math.random() > 0.5 ? '01' : '10';
                  ctx.fillText(text, x, y);
                }
              }
            }
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            break;
            
          case 'neonrain':
            // Neon Rain Effect
            const rainDensity = document.getElementById('rainDensity') ? 
              parseInt(document.getElementById('rainDensity').value) / 100 : 0.5;
            const rainColor = document.getElementById('rainColor') ? 
              hexToRgb(document.getElementById('rainColor').value) : { r: 255, g: 0, b: 255 };
            
            // Gambar hujan
            ctx.strokeStyle = `rgba(${rainColor.r}, ${rainColor.g}, ${rainColor.b}, 0.7)`;
            ctx.lineWidth = 2;
            
            for (let i = 0; i < width * height * rainDensity / 1000; i++) {
              const x = Math.random() * width;
              const y = Math.random() * height;
              const length = 10 + Math.random() * 20;
              
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x, y + length);
              ctx.stroke();
            }
            
            // Gambar gambar asli dengan blending
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.7;
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            break;
        }
      }

      // Fungsi untuk menerapkan adjustments
      function applyAdjustments(ctx, width, height) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        const brightness = parseInt(document.getElementById('brightness').value);
        const contrast = parseInt(document.getElementById('contrast').value);
        const saturation = parseInt(document.getElementById('saturation').value);
        const exposure = parseInt(document.getElementById('exposure').value);
        const temperature = parseInt(document.getElementById('temperature').value);
        
        for (let i = 0; i < data.length; i += 4) {
          let r = data[i];
          let g = data[i + 1];
          let b = data[i + 2];
          
          // Brightness
          r += brightness;
          g += brightness;
          b += brightness;
          
          // Contrast
          const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
          r = contrastFactor * (r - 128) + 128;
          g = contrastFactor * (g - 128) + 128;
          b = contrastFactor * (b - 128) + 128;
          
          // Exposure
          const exposureFactor = Math.pow(2, exposure / 100);
          r *= exposureFactor;
          g *= exposureFactor;
          b *= exposureFactor;
          
          // Temperature
          const tempFactor = temperature / 100;
          r += tempFactor * 30;
          b -= tempFactor * 30;
          
          // Saturation
          const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
          const satFactor = saturation / 100 + 1;
          r = gray + satFactor * (r - gray);
          g = gray + satFactor * (g - gray);
          b = gray + satFactor * (b - gray);
          
          // Clamp values
          data[i] = Math.min(255, Math.max(0, r));
          data[i + 1] = Math.min(255, Math.max(0, g));
          data[i + 2] = Math.min(255, Math.max(0, b));
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      // Fungsi untuk menerapkan frame
      function applyFrame(ctx, width, height) {
        const frameStyle = document.querySelector('.frame-option.active').getAttribute('data-frame');
        const frameSize = parseInt(document.getElementById('frameSize').value);
        const frameColor = document.getElementById('frameColor').value;
        
        if (frameStyle === 'none') return;
        
        ctx.strokeStyle = frameColor;
        
        switch(frameStyle) {
          case 'simple':
            ctx.lineWidth = frameSize;
            ctx.strokeRect(frameSize / 2, frameSize / 2, width - frameSize, height - frameSize);
            break;
            
          case 'vintage':
            ctx.lineWidth = frameSize;
            ctx.strokeRect(frameSize / 2, frameSize / 2, width - frameSize, height - frameSize);
            
            // Tambahkan inner frame
            ctx.lineWidth = frameSize / 2;
            ctx.strokeRect(frameSize, frameSize, width - frameSize * 2, height - frameSize * 2);
            break;
            
          case 'modern':
            // Frame modern dengan sudut bulat
            const cornerRadius = frameSize * 2;
            
            ctx.beginPath();
            ctx.moveTo(cornerRadius, 0);
            ctx.lineTo(width - cornerRadius, 0);
            ctx.quadraticCurveTo(width, 0, width, cornerRadius);
            ctx.lineTo(width, height - cornerRadius);
            ctx.quadraticCurveTo(width, height, width - cornerRadius, height);
            ctx.lineTo(cornerRadius, height);
            ctx.quadraticCurveTo(0, height, 0, height - cornerRadius);
            ctx.lineTo(0, cornerRadius);
            ctx.quadraticCurveTo(0, 0, cornerRadius, 0);
            ctx.closePath();
            
            ctx.lineWidth = frameSize;
            ctx.stroke();
            break;
            
          case 'polaroid':
            // Frame polaroid
            ctx.fillStyle = frameColor;
            ctx.fillRect(0, 0, width, height);
            
            // Buat bagian dalam gambar
            ctx.fillStyle = 'white';
            const innerWidth = width - frameSize * 2;
            const innerHeight = height - frameSize * 3;
            ctx.fillRect(frameSize, frameSize, innerWidth, innerHeight);
            
            // Gambar gambar di bagian dalam
            ctx.drawImage(
              ctx.canvas, 
              frameSize, frameSize, innerWidth, innerHeight,
              frameSize, frameSize, innerWidth, innerHeight
            );
            break;
            
          case 'film':
            // Frame film strip
            ctx.fillStyle = frameColor;
            ctx.fillRect(0, 0, width, height);
            
            // Buat bagian dalam gambar
            const filmInnerWidth = width - frameSize * 2;
            const filmInnerHeight = height - frameSize * 2;
            ctx.fillStyle = 'white';
            ctx.fillRect(frameSize, frameSize, filmInnerWidth, filmInnerHeight);
            
            // Gambar gambar di bagian dalam
            ctx.drawImage(
              ctx.canvas, 
              frameSize, frameSize, filmInnerWidth, filmInnerHeight,
              frameSize, frameSize, filmInnerWidth, filmInnerHeight
            );
            
            // Tambahkan lubang film
            ctx.fillStyle = frameColor;
            const holeSize = frameSize / 2;
            const holeSpacing = frameSize * 2;
            
            for (let y = frameSize; y < height - frameSize; y += holeSpacing) {
              ctx.beginPath();
              ctx.arc(frameSize / 2, y, holeSize, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.beginPath();
              ctx.arc(width - frameSize / 2, y, holeSize, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
        }
      }
      
      // Fungsi untuk menerapkan text
      function applyText(ctx, width, height) {
        const textContent = document.getElementById('textContent').value;
        if (!textContent) return;
        
        const textStyle = document.querySelector('.text-style-option.active').getAttribute('data-style');
        const fontSize = parseInt(document.getElementById('fontSize').value);
        const textColor = document.getElementById('textColor').value;
        const textPosition = document.getElementById('textPosition').value;
        
        ctx.font = `${fontSize}px Poppins`;
        ctx.fillStyle = textColor;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let x, y;
        
        switch(textPosition) {
          case 'top-left':
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            x = fontSize;
            y = fontSize;
            break;
          case 'top-center':
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            x = width / 2;
            y = fontSize;
            break;
          case 'top-right':
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            x = width - fontSize;
            y = fontSize;
            break;
          case 'center':
            x = width / 2;
            y = height / 2;
            break;
          case 'bottom-left':
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            x = fontSize;
            y = height - fontSize;
            break;
          case 'bottom-center':
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            x = width / 2;
            y = height - fontSize;
            break;
          case 'bottom-right':
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            x = width - fontSize;
            y = height - fontSize;
            break;
        }
        
        if (textStyle === 'bold') {
          ctx.font = `bold ${fontSize}px Poppins`;
        } else if (textStyle === 'italic') {
          ctx.font = `italic ${fontSize}px Poppins`;
        }
        
        if (textStyle === 'outline') {
          ctx.strokeStyle = textColor;
          ctx.lineWidth = 2;
          ctx.strokeText(textContent, x, y);
        } else {
          ctx.fillText(textContent, x, y);
        }
      }
      
      // Fungsi untuk menerapkan sticker
      function applySticker(ctx, width, height) {
        if (!selectedSticker) return;
        
        const stickerSize = parseInt(document.getElementById('stickerSize').value);
        
        ctx.font = `${stickerSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Default position di tengah
        const x = width / 2;
        const y = height / 2;
        
        ctx.fillText(selectedSticker, x, y);
      }
      
      // Fungsi untuk menerapkan advanced effects
      function applyAdvancedEffects(ctx, width, height) {
        const blur = parseInt(document.getElementById('blur').value);
        const sharpen = parseInt(document.getElementById('sharpen').value);
        const noiseReduction = parseInt(document.getElementById('noiseReduction').value);
        const perspectiveH = parseInt(document.getElementById('perspectiveH').value);
        const perspectiveV = parseInt(document.getElementById('perspectiveV').value);
        
        // Blur
        if (blur > 0) {
          ctx.filter = `blur(${blur}px)`;
          ctx.drawImage(ctx.canvas, 0, 0);
          ctx.filter = 'none';
        }
        
        // Sharpen
        if (sharpen > 0) {
          const sharpenAmount = sharpen / 100;
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          
          const sharpenData = ctx.createImageData(width, height);
          const sharpenPixels = sharpenData.data;
          
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const idx = (y * width + x) * 4;
              
              // Hitung sharpen
              const sharpenR = data[idx] + sharpenAmount * (
                data[idx] - (
                  data[((y - 1) * width + (x - 1)) * 4] +
                  data[((y - 1) * width + x) * 4] +
                  data[((y - 1) * width + (x + 1)) * 4] +
                  data[(y * width + (x - 1)) * 4] +
                  data[(y * width + (x + 1)) * 4] +
                  data[((y + 1) * width + (x - 1)) * 4] +
                  data[((y + 1) * width + x) * 4] +
                  data[((y + 1) * width + (x + 1)) * 4]
                ) / 8
              );
              
              const sharpenG = data[idx + 1] + sharpenAmount * (
                data[idx + 1] - (
                  data[((y - 1) * width + (x - 1)) * 4 + 1] +
                  data[((y - 1) * width + x) * 4 + 1] +
                  data[((y - 1) * width + (x + 1)) * 4 + 1] +
                  data[(y * width + (x - 1)) * 4 + 1] +
                  data[(y * width + (x + 1)) * 4 + 1] +
                  data[((y + 1) * width + (x - 1)) * 4 + 1] +
                  data[((y + 1) * width + x) * 4 + 1] +
                  data[((y + 1) * width + (x + 1)) * 4 + 1]
                ) / 8
              );
              
              const sharpenB = data[idx + 2] + sharpenAmount * (
                data[idx + 2] - (
                  data[((y - 1) * width + (x - 1)) * 4 + 2] +
                  data[((y - 1) * width + x) * 4 + 2] +
                  data[((y - 1) * width + (x + 1)) * 4 + 2] +
                  data[(y * width + (x - 1)) * 4 + 2] +
                  data[(y * width + (x + 1)) * 4 + 2] +
                  data[((y + 1) * width + (x - 1)) * 4 + 2] +
                  data[((y + 1) * width + x) * 4 + 2] +
                  data[((y + 1) * width + (x + 1)) * 4 + 2]
                ) / 8
              );
              
              sharpenPixels[idx] = Math.min(255, Math.max(0, sharpenR));
              sharpenPixels[idx + 1] = Math.min(255, Math.max(0, sharpenG));
              sharpenPixels[idx + 2] = Math.min(255, Math.max(0, sharpenB));
              sharpenPixels[idx + 3] = data[idx + 3];
            }
          }
          
          ctx.putImageData(sharpenData, 0, 0);
        }
        
        // Noise Reduction
        if (noiseReduction > 0) {
          const noiseAmount = noiseReduction / 100;
          const imageData = ctx.getImageData(0, 0, width, height);
          const data = imageData.data;
          
          const noiseData = ctx.createImageData(width, height);
          const noisePixels = noiseData.data;
          
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const idx = (y * width + x) * 4;
              
              // Hitung rata-rata piksel di sekitar
              let r = 0, g = 0, b = 0, count = 0;
              
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  const nIdx = ((y + dy) * width + (x + dx)) * 4;
                  r += data[nIdx];
                  g += data[nIdx + 1];
                  b += data[nIdx + 2];
                  count++;
                }
              }
              
              // Interpolasi antara piksel asli dan rata-rata
              noisePixels[idx] = data[idx] * (1 - noiseAmount) + (r / count) * noiseAmount;
              noisePixels[idx + 1] = data[idx + 1] * (1 - noiseAmount) + (g / count) * noiseAmount;
              noisePixels[idx + 2] = data[idx + 2] * (1 - noiseAmount) + (b / count) * noiseAmount;
              noisePixels[idx + 3] = data[idx + 3];
            }
          }
          
          ctx.putImageData(noiseData, 0, 0);
        }
        
        // Perspective Correction
        if (perspectiveH !== 0 || perspectiveV !== 0) {
          const perspectiveData = ctx.createImageData(width, height);
          const perspectivePixels = perspectiveData.data;
          
          const hFactor = perspectiveH / 100;
          const vFactor = perspectiveV / 100;
          
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              // Hitung offset perspective
              const offsetX = (x - width / 2) * hFactor * (y / height);
              const offsetY = (y - height / 2) * vFactor * (x / width);
              
              // Hitung koordinat sumber
              const sourceX = Math.floor(x + offsetX);
              const sourceY = Math.floor(y + offsetY);
              
              // Salin piksel
              if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                const sourceIdx = (sourceY * width + sourceX) * 4;
                const targetIdx = (y * width + x) * 4;
                
                perspectivePixels[targetIdx] = data[sourceIdx];
                perspectivePixels[targetIdx + 1] = data[sourceIdx + 1];
                perspectivePixels[targetIdx + 2] = data[sourceIdx + 2];
                perspectivePixels[targetIdx + 3] = data[sourceIdx + 3];
              }
            }
          }
          
          ctx.putImageData(perspectiveData, 0, 0);
        }
      }
      
      // Fungsi untuk update informasi gambar
      function updateImageInfo(img, file) {
        document.getElementById('oriDim').textContent = `${img.width} × ${img.height} px`;
        document.getElementById('oriSize').textContent = formatFileSize(file.size);
      }
      
      // Fungsi untuk update informasi output
      function updateOutputInfo(width, height) {
        document.getElementById('outDim').textContent = `${width} × ${height} px`;
        
        // Hitung ukuran file output (perkiraan)
        const quality = document.getElementById('qualityRange').value / 100;
        const estimatedSize = originalImage ? width * height * quality * 0.1 : 0; // Perkiraan kasar
        document.getElementById('outSize').textContent = formatFileSize(estimatedSize);
        
        // Update mode terpilih
        document.getElementById('outMode').textContent = activeMode;
        
        // Update perubahan ukuran
        const sizePercent = document.getElementById('sizeRange').value;
        document.getElementById('ratio').textContent = `${sizePercent}%`;
      }
      
      // Fungsi untuk format ukuran file
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }
      
      // Fungsi untuk konversi hex ke RGB
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      }
      
      // Fungsi untuk menampilkan toast
      function showToast(message, isError = false) {
        const toast = document.getElementById('toast');
        toast.innerHTML = `<i class="fas ${isError ? 'fa-exclamation-circle' : 'fa-check-circle'}"></i> ${message}`;
        toast.className = isError ? 'toast error show' : 'toast show';
        
        setTimeout(() => {
          toast.className = toast.className.replace('show', '');
        }, 3000);
      }
    });
    
    document.addEventListener("DOMContentLoaded", () => {
  const infoHeader = document.querySelector(".info-header");
  const infoContent = document.querySelector(".info-content");
  const icon = infoHeader.querySelector("i.fas.fa-chevron-down");

  infoHeader.addEventListener("click", () => {
    infoContent.classList.toggle("active");
    icon.style.transform = infoContent.classList.contains("active")
      ? "rotate(180deg)"
      : "rotate(0deg)";
  });
});
  </script>
  <script>
document.addEventListener('DOMContentLoaded', function() {
    // Ambil elemen yang diperlukan
    const qualityRange = document.getElementById('qualityRange');
    const qualityVal = document.getElementById('qualityVal');
    const preview = document.getElementById('preview');
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Fungsi untuk menerapkan efek kualitas secara     // Fungsi untuk menerapkan efek kualitas secara real-time
    function applyQualityEffect() {
        if (!preview.src || !preview.complete) return;
        
        const quality = parseInt(qualityRange.value);
        qualityVal.textContent = quality;
        
        // Set canvas size sama dengan gambar
        canvas.width = preview.naturalWidth;
        canvas.height = preview.naturalHeight;
        
        // Gambar ulang ke canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(preview, 0, 0);
        
        // Terapkan efek berdasarkan kualitas
        if (quality < 90) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Efek kualitas rendah (noise dan blur)
            const intensity = (90 - quality) / 10;
            
            // Tambahkan noise
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * intensity * 20;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Terapkan blur untuk kualitas sangat rendah
            if (quality < 70) {
                ctx.filter = `blur(${(70 - quality) / 20}px)`;
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }
        }
        
        // Update preview dengan hasil efek
        preview.src = canvas.toDataURL('image/jpeg', quality / 100);
    }
    
    // Event listener untuk slider kualitas
    qualityRange.addEventListener('input', applyQualityEffect);
    
    // Event listener saat gambar di-upload
    document.getElementById('imageUpload').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                preview.src = event.target.result;
                preview.onload = applyQualityEffect;
            };
            reader.readAsDataURL(file);
        }
    });
    
    // Inisialisasi jika sudah ada gambar
    if (preview.src) {
        preview.onload = applyQualityEffect;
    }
});
</script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    let index = 1;
    const total = 10;
    setInterval(() => {
      index = (index % total) + 1; // looping 1-10
      document.body.style.backgroundImage = `var(--bg${index})`;
    }, 5000); // ganti tiap 5 detik
  });
</script>
</body>
</html>